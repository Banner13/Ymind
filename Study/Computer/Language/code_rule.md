



	###代码书写原则：
		#TDD 是测试驱动开发（Test-Driven Development），它同样也是敏捷开发的一种方法论。
		TDD 是再开发代码之前，先编写单元测试用例，用测试的代码确定要编写什么样的代码。
		它的整个思路就是通过测试来驱动整个软件开发的进度，当然这对测试人员来说是一个更高的要求和标准。

		TDD 三大原则：
			You are not allowed to write any production code unless it is to make a failing unit test pass.
			You are not allowed to write any more of a unit test than is sufficient to fail; and compilation failures are failures.
			You are not allowed to write any more production code than is sufficient to pass the one failing unit test.

		翻译：
			除非是为了测试失败的单元测试通过，否则不允许编写任何生产代码
			在一个单元测试中，只允许编写刚好能够导致失败的内容（编译错误也算失败）
			只允许编写刚好能够使一个失败的单元测试通过的产品代码




	项目编程规范


	目 录

	代码总体原则和术语定义

	第一章：排版与格式…………………………………………………………………………………
	1.1 注释……………………………………………………………………………………
	1.2 表达式…………………………………………………………………………………
	第二章：标识符命名与定义…………………………………………………
	2.1 通用命名规则……………………………………………………………………
	2.2 变量命名规则……………………………………………………………………
	2.3 函数命名规则……………………………………………………………………
	2.4 宏和常量的命名规则…………………………………………………………
	第三章：头文件和定义……………………………………………………………………
	3.1 头文件…………………………………………………………………………………
	3.2 变量定义………………………………………………………………………………
	3.3 宏、常量定义……………………………………………………………………………
	第四章：基本要求………………………………………………………………………………
	4.1 质量保证……………………………………………………………………………
	4.2 程序效率……………………………………………………………………………
	第五章：其他要求………………………………………………………………
	5.1 安全性…………………………………………………………………………………
	5.1.1 字符串操作安全………………………………………………………………
	5.1.2 整数安全…………………………………………………………………
	5.1.3 格式化输出安全……………………………………………………………
	5.1.4 文件I/O安全……………………………………………………………
	5.1.5 其他…………………………………………………………………
	5.2 可测性……………………………………………………………………………………
	5.3 可移植性…………………………………………………………………………………
	第六章：C++特性………………………………………………………………………………………
	6.1 常量……………………………………………………………………………………
	6.2 初始化和类型转换………………………………………………………………………
	6.2.1 声明、定义和初始化…………………………………………………………………
	6.2.2 类型转换…………………………………………………………………
	6.3 函数………………………………………………………………………
	6.3.1 内联函数…………………………………………………………………
	6.3.2 函数参数…………………………………………………………………
	6.3.3 函数指针………………………………………………………………
	6.4 类…………………………………………………………………
	6.4.1 类的设计…………………………………………………………
	6.4.2 构造、赋值和析构………………………………………………
	6.4.3 继承………………………………………………………………
	6.4.4 重载……………………………………………………………
	6.5 作用域、模板和C++其他特性………………………………………………
	6.5.1 作用域…………………………………………………………………
	6.5.2 模板…………………………………………………………………
	6.5.3 其他…………………………………………………………………
	6.6 资源分配和释放……………………………………………………………
	6.7 并发………………………………………………………………………
	6.8 可移植性（兼容性）………………………………………………………………………
	业界编程规范和书籍
	业界编程规范
	《googleC++codestyle》
	《C++编程规范101条规则、准则与最佳实践》
	《C++Primer》
	《effectiveC++》


	代码总体原则和术语定义

	代码总体原则
	清晰第一
	清晰性是易于维护、易于重构的程序必须具备的特征。
	简洁为美
	简洁就是易于理解并且易于实现。
	代码风格一致
	如果重构/修改其他风格的代码时，尽量根据现有代码的风格继续编写代码。



	术语定义
	原则：编程时必须坚持的指导思想。
	规则：编程时必须遵守的约定。
	建议：编程时必须加以考虑的约定。
	说明：对此原则/规则/建议进行必要的说明。
	示例：对此原则/规则/建议给出的例子。


	第一章：排版与格式
	规则：程序块采用缩进风格编写，每级缩进为4个空格。
	注：新写的代码块使用该要求，若是修改原有代码，应与原代码保持风格一致。再IDE工具或gitk页面显示都应对齐。
		说明：当前各种编辑器/IDE都支持TAB键自动转空格输入，需要打开并设置相关功能。
		Source Insight可在菜单栏Options >> Preferences >> Syntax Formatting >> File Types..>> File Type: 栏选择对应的文件后 >> 勾选Editing Options中的 Expand tabs to spaces | Tab width: 设置为4；
		如果有显示TAB，空格的功能也应该打开，方便及时纠正输入错误。
		Source Insight勾选Visible tabs | Visible spaces;
		示例：
		宏定义、编译开关、条件预处理语句可以顶格（或使用自定义的排版方案，但产品/模块内必须保持一致）。

	规则：相对独立的程序块之间、变量说明之后必须加空行。
		示例：

	规则：一条语句不能过长，如不能拆分需要分行写。
		建议：
		换行时要增加一级缩进，使代码可读性更好。
		低优先级操作符处划分新行；换行时操作符有应该放下来，放在新行首。
		换行时建议一个完整的语句放在一起，不要根据字符数断行。
	示例：

	规则：多个短语句（包括赋值语句）不允许写在同一行内，即一行只写一句语句。
		示例：

	规则：if、for、do、while、case、switch、default等语句独占一行。
		说明：执行语句必须用缩进风格写。
		建议：
		if、for、do、while、case、switch、default等语句后的执行语句增加成对的“{ }”；
		如果if/else 配套语句中有一个分支有“{ }”，那么另一个分支即使只有一行代码也建议增加“{ }”；
		添加“{” 使用独占一行的写法；可以和if在一个缩进级别，也可以在下一个缩进级别；但是如果时修改原代码，保持和原代码风格一致。在已经非常清晰的语句中没有必要再留空格，如括号内侧（即左括号后面和右括号前面）不需要加空格，多重括号间不必加空格，因为在C语言中括号已经是最清晰的标志了。

	规则：
		逗号、分号只在后面加空格。
		比较操作符，赋值操作符“ = 、 += ”，算术操作符“ + 、 % ”，逻辑操作符“ && 、 & ”，位操作符“ << 、 ^ ”等双目操作符的前后加空格。
		“！、~、++、--、*（内容操作）、&（地址操作符）”等单目操作符前后不加空格。
		“->”、“.”前后不加空格。
		if、for、while、switch等与后面的括号应加空格，使if等关键字更为突出、明显。

	建议：源程序中关系较为紧密的代码应该尽可能相邻。


	1.1 注释
	原则：注释的内容要清楚、明了，含义正确，防止注释二义性。
		说明：有歧义的注释反而会导致维护者更难看懂代码，正如带两块表反而不知道准确时间

	原则：注释不要重复描述代码，而是在代码的功能、意图层次上进行注释，即注释内容应该用于解释代码难以直接表达的意图。
	说明：对于实现代码中巧妙的、晦涩的、有趣的、重要的地方加以注释，出彩的或复杂的代码块前面要加注释。

	规则：修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性。不再有用的注释要删除。
	规则：文件头部应进行注释，注释必须列出：版权声明、版本号、生成日期、作者姓名、内容、功能说明、与其他文件的关系、修改日志等，头文件的注释还应有函数功能简要说明。
		示例：

	规则：函数声明处注释“描述函数功能、性能及用法，包括输入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、设计约束等。
	规则：全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明。
	规则：注释应放在其代码上方相邻位置或右方，不可放在下方。如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同。超过三行的注释，建议放在代码上方。
	规则：对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在case语句处理完、下一个case语句前加上明确的注释。case语句超过两行，必须添加” { }”，” break ”不计入行数。
		示例：

	规则：避免在注释中使用缩写，除非时业界通用或者子系统内标准化的缩写。
	规则：统一注释风格。
	建议：避免在一行代码或表达式的中间插入注释。
	建议：注释应考虑程序易读及外观排版的因素，注释建议使用英文。
	建议：文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式。
	建议：注释符（包括 /* 、*/ 和 // ）与注释内容之间要用一个空格进行分隔。


	1.2 表达式
	规则：表达式的值在标准所允许的任何运算次序下都应该是相同的。
	示例：
		自增或自减操作符
		函数参数
			说明：函数参数通常从右向左压栈，但函数参数的计算次序不一定与压栈次序相同。
		函数指针
		函数调用
		嵌套赋值语句
	说明：表达式中嵌套的赋值可以产生附加的副作用。不给这种能导致对于运算次序的依赖提供任何机会的最好做法是，不要在表达式中嵌套赋值语句。
		volatile访问
	说明：限定符volatile表示可能被其他途径更改的变量，示例硬件自动更新的寄存器。编译器不会优化对volatile变量的读取。

	建议：函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利。
	建议：赋值语句不要写在if等语句中，或者作为函数的参数使用。
		示例：

	建议：用括号明确表达式的操作顺序，避免过分依赖默认优先级。
	建议：赋值操作符不能使用在产生布尔值的表达式上。

	第二章：标识符命名与定义
	2.1 通用命名规则
	目前比较常用命名风格：
		unix like风格：单词用小写，单词间用_隔开，示例“ text_mutex ”,“  kernel_text_address ”。
		Windows风格：单词连在一起，每个单词首字母大写。示例“ TimingMode ”。
		驼峰命名法：

	原则：标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。
	原则：除了常用的通用缩写以外，不适应单词缩写，不得使用汉语拼音。
	规则：除了修改原有代码应保持与原代码风格一致，新写的代码均采用驼峰命名的规则。
	建议：用正确的反义词组命名具有互斥意义的变量或相反动作的函数等。
	建议：尽量避免命名中出现数字编号，除非逻辑上的确需要编号。
	建议：标识符前不应添加模块、项目、产品的名称作为前缀。
	建议：平台/驱动等适配代码的标识符应和原来的风格保持一致。
	建议：重构/修改部分代码时，应保持和原有代码的风格一致。


	2.2 变量命名规则
	规则：全局变量应增加 g_ 前缀。
	规则：静态变量应增加 s_ 前缀。
	规则：禁止使用单字节命名变量，但允许定义 i , j, k 作为局部循环变量。
	建议：使用名词或者形容词+名词方式命名变量。

	2.3 函数命名规则
	建议：函数命名应以函数要执行的动作命名，一般采用动词或者动词加名词的结构。
	建议：函数指针除了前缀，其他按照函数的命名规则命名。

	2.4 宏和常量的命名规则
	规则：对于数字或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线“_”的方式命名。
	示例：

	规则：除了头文件或者编译开关等特殊标识定义，宏定义不能使用下划线”_”开头和结尾。

	第三章：头文件和定义
	3.1 头文件
	背景
	对于C语言来说，头文件的设计体现了大部分的系统设计。不合理的头文件布局是编译时间过长的原因，不合理的头文件实际上是不合理的设计。
	合理的头文件划分体现了系统设计的思想，但是从编程规范的角度看，仍然有一些通用的方法，用来合理规划头文件。本章节介绍的一些方法，对于合理规划头文件会有一定的帮助。

	原则：头文件中适合放置接口的声明，不适合放置实现。
	说明：头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。
		内部使用的函数（相当于类的私有方法）声明不应放在头文件中，内部使用的宏、枚举、结构定义不应放入头文件中。
		变量定义不应放在头文件中，应放在.c文件中。
		变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。即使必须使用全局变量，也只应当在.c中定义全局变量，在.h中仅声明变量为全局的。

	原则：头文件应当职责单一。
	说明：头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。很多现有代码中头文件过大，职责过多，再加上循环依赖的问题，可能导致为了在.c中使用一个宏，而包含十几个头文件。

	原则：头文件应向稳定的方向包含。
	说明：头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。

	规则：每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。
	说明：如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。
	规则：禁止头文件循环依赖。
	说明：头文件循环依赖，指a. h包含b. h， b.h包含c. h， c.h包含a.h之类导致任何一个头文件修改，都导致所有包含了a. h/b. h/c. h的代码全部重新编译一遍。而如果是单向依赖，如a. h包含b. h，b.h包含 c.h，而c.h不包含任何头文件，则修改a. h不会导致包含了b. h/c. h的源代码重新编译。

	规则：.c / .h文件禁止包含用不到的头文件。
	说明：很多系统中头文件包含关系复杂，开发人员为了省事起见，可能不会去一一钻研，直接包含一切想到的头文件，甚至有些产品干脆发布了一个god.h，其中包含了所有头文件，然后发布给各个项目组使用，这种只图一时省事的做法，导致整个系统的编译时间进一步恶化，并对后来人的维护造成了巨大的麻烦。

	规则：头文件应当自包含。
	说明：简单的说，自包含就是任意一个头文件均可独立编译。如果一个文件包含某个头文件，还要包含另外一个头文件才能工作的话，就会增加交流障碍，给这个头文件的用户增添不必要的负担。

	规则：总是编写内部#include保护符（#define保护）。
	说明：多次包含一个头文件可以通过认真的设计来避免。如果不能做到这一点，就需要采取阻止头文件内容被包含多于一次的机制。
	通常的手段是为每个文件配置一个宏，当头文件第一次被包含时就定义这个宏，并在头文件被再次包含时使用它以排除文件内容。
	所有头文件都应当使用#define防止头文件被多重包含，命名格式为FILENAME_H，为了保证唯一性，更好的命名方法是PRO_JECTNAME_PATH_FILENAME_H。
	注：没有在宏最前面加上“_”，即使用FILENAME_H代替_FILENAME_H_，是因为一般以“_”和“__”开头的标识符为系统保留或者标准库使用，在有些静态检查工具中，若全局可见的标识符以“_”开头会给出告警。
	定义包含保护符时，应该遵守如下规则：
		保护符使用唯一名称。
		不要在受保护部分的前后放置代码或者注释。
	例外情况：头文件的版权声明部分以及头文件的整体注释部分（如阐述此头文件的开发背景、使用注意事项等）可以放在保护符（#ifndef XXH）前面。

	规则：禁止在头文件中定义变量
	说明：在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。

	规则：只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。
	规则：禁止在extern “ c ”中包含头文件。
	说明:在extern " C "中包含头文件,会导致extern " C "嵌套, Visual Studio对extern " C "嵌套层次有限制，嵌套层次太多会编译错误。

	建议：一个模块通常包含多个.c文件，建议放在同一个目录下，目录名即为模块名。为方便外部使用者，建议每一个模块提供一个.h，文件名为目录名。
	说明：需要注意的是，这个.h并不是简单的包含所有内部的.h，它是为了模块使用者的方便，对外整体提供的模块接口。

	建议：如果一个模块包含多个子模块，则建议每一个子模块提供一个对外的.h，文件名为子模块名。
	说明：降低接口使用者的编写难度。

	建议：头文件不要使用非习惯用法的扩展名，如 .inc。
	说明：目前很多产品中使用了 .inc作为头文件扩展名，这不符合c语言的习惯用法。在使用 .inc作为头文件扩展名的产品，习惯上用于标识此头文件为私有头文件。但是从产品的实际代码来看，这一条并没有被遵守，一个 .inc文件被多个.c包含比比皆是。本规范不提倡将私有定义单独放在头文件中，除此之外，使用 .inc还导致source insight，Visual stduio等IDE工具无法识别其为头文件，导致很多功能不可用，如“跳转到变量定义处”。虽然可以通过配置，强迫IDE识别 .inc为头文件，但是有些软件无法配置，如Visual Assist只能识别h而无法通过配置识别 .inc。

	建议：同一产品统一包含头文件排列方式。
	说明：常见的包含头文件排列方式：功能块排序、文件名升序、稳定度排序。
	在项目中，应先包含标准库等的头文件，然后才包含其他头文件。


	3.2 变量的定义
	原则：一个变量只有一个功能，不能把一个变量用作多种用途。
	示例：

	原则：结构功能单一；不要设计面面俱到的数据结构。
	说明：相关的一组信息才是构成一个结构体的基础，结构的定义应该可以明确的描述一个对象，而不是一组相关性不强的数据的集合。
	设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一个结构中。

	原则：不用或者少用全局变量。
	规则：防止局部变量和全局变量同名。
	规则：严禁使用未经初始化的变量作为右值。
	建议：构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。
	建议：使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。
	说明：避免直接暴露内部数据给外部模型使用，是防止模块间耦合最简单有效的方法。
	定义的接口应该有比较明确的意义，比如一个风扇管理功能模块，有自动和手动工作模式，那么设置、查询工作模块就可以定义接口为SetFanWorkMode，GetFanWorkMode；查询转速就可以定义为GetFanSpeed；风扇支持节能功能开关，可以定义EnabletFanSavePower等等。

	建议：在首次使用前初始化变量，初始化的地方离使用的地方越近越好。
	说明：未初始化变量是C和C++程序中错误的常见来源。在变量首次使用前确保正确初始化在较好的方案中，变量的定义和初始化要做到亲密无间。

	建议：明确全局变量的初始化顺序，避免跨模块的初始化依赖。
	说明：系统启动阶段，使用全局变量前，要考虑到该全局变量在什么时候初始化，使用全局变量和初始化全局变量，两者之间的时序关系，谁先谁后，一定要分析清楚，不然后果往往是低级而又灾难性的。

	建议：尽量减少没有必要的数据类型默认转换与强制转换。
	说明：当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。


	3.3 宏、常量定义
	规则：用宏定义表达式时，要使用完备的括号。
	说明：因为宏只是简单的代码替换，不会像函数一样先将参数计算后，再传递。 
	示例：如下定义的宏都存在一定的风险。

	规则：将宏所定义的多条表达式放在大括号中。
		示例：错误示例	下面宏所定义的多条语句，只执行了第一句。
	说明:更好的方法时多条语句写成do while(0)的方式。
	示例：错误示例

	规则：使用宏时，不允许参数发生变化。
		示例：错误示例

	规则：不允许直接使用魔鬼数字。
	建议：除非必要，应尽可能使用函数代替宏。
	建议：常量建议使用const定义代替宏。
	建议：宏定义中尽量不使用return， goto， continue， break等改变程序流程的语句。

	第四章：基本要求
	4.1 质量保证
	原则：代码质量保证优先原则。
	（1）正确性，指程序要实现设计要求的功能。
	（2）简洁性，指程序易于理解并且易于实现。
	（3）可维护性，指程序被修改的能力，包括纠错、改进、新需求或功能规格变化的适应能力。
	（4）可靠性，指程序在给定时间间隔和环境条件下，按设计要求成功运行程序的概率。
	（5）代码可测试性，指软件发现故障并隔离、定位故障的能力，以及在一定的时间和成本前提下，进行测试设计、测试执行的能力。
	（6）代码性能高效，指是尽可能少地占用系统资源，包括内存和执行时间。
	（7）可移植性，指为了在原来设计的特定环境之外运行，对系统进行修改的能力。
	（8）个人表达方式/个人方便性，指个人编程习惯。

	原则：要时刻注意易混淆的操作符。
	说明：包括易混淆和易用错操作符。
	示例：易混淆的操作符

	示例：易用错的操作符

	原则：必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等。
	原则：不仅关注接口，同样要关注实现。
	规则：禁止内存操作越界。
	说明：内存操作主要是指对数组、指针、内存地址等的操作。内存操作越界是软件系统主要错误之一，后果往往非常严重，所以当我们进行这些操作时一定要仔细小心。
	例如：错误示例

	坚持下列措施可以避免内存越界：
		数组的大小要考虑最大情况，避免数组分配空间不够。
		避免使用危险函数sprintf/vsprintf/strcpy/strcat/gets操作字符串，使用相对安全的函数snprintf/strncpy/strncat/fgets代替。
		使用memcpy/memset时一定要确保长度不要越界。
		字符串考虑最后的“\0”，确保所有字符串是以“\0”结束。
		指针加减操作时，考虑指针类型长度。
		数组下标进行检查。
		使用sizeof或者strlen计算结构/字符串长度，避免手工计算。

	规则：禁止内存泄漏。
	说明：内存和资源（包括定时器/文件句柄/Socket/队列/信号量/GUI等各种资源）泄漏是常见的错误。
		示例：错误示例

	坚持下列措施可以避免内存泄漏：
		异常出口处检查内存、定时器/文件句柄/Socket/队列/信号量/GUI等资源是否全部释放删除结构指针时，必须从底层向上层顺序删除。
		使用指针数组时，确保在释放数组时，数组中的每个元素指针是否已经提前被释放了避免重复分配内存。
		小心使用有return，break语句的宏，确保前面资源已经释放检查队列中每个成员是否释放。

	规则：禁止引用已经释放的内存空间。
	说明：在实际编程过程中，稍不留心就会出现在一个模块中释放了某个内存块，而另一模块在随后的某个时刻又使用了它。要防止这种情况发生。

	规则：编程时,要防止差1错误。
	说明：此类错误一般是由于把“<=”误写成“<”或“>=”误写成“>”等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。当编完程序后，应对这些操作符进行彻底检查。使用变量时要注意其边界值的情况。

	规则:所有的if ... else if结构应该由else子句结束； switch语句必须有default分支。
	建议:函数中分配的内存，在函数退出之前要释放。
	说明：有很多函数申请内存，保存在数据结构中，要在申请处加上注释，说明在何处释放。

	建议:if语句尽量加上else分支，对没有else分支的语句要小心对待。
	建议:不要滥用goto语句。
	说明：goto语句会破坏程序的结构性，所以除非确实需要，最好不使用goto语句。

	建议:时刻注意表达式是否会上溢、下溢。


	4.2 程序效率
	原则：在保证软件系统的正确性、简洁、可维护性、可靠性及可测性的前提下，提高代码效率。本章节后面所有的规则和建议，都应在不影响前述可读性等质量属性的前提下实施。
	说明：不能一味地追求代码效率，而对软件的正确、简洁、可维护性、可靠性及可测性造成影响。

	原则：通过对数据结构、程序算法的优化来提高效率。
	建议：将不变条件的计算移到循环体外。
	说明：将循环中与循环无关，不是每次循环都要做的操作，移到循环外部执行。

	建议：对于多维大数组，避免来回跳跃式访问数组成员。
	建议：创建资源库，以减少分配对象的开销。
	说明：使用线程池机制，避免线程频繁创建、销毁的系统调用；使用内存池，对于频繁申请、释放的小块内存，一次性申请一个大块的内存，当系统申请内存时，从内存池获取小块内存，使用完毕再释放到内存池中，避免内存申请释放的频繁系统调用。

	建议：将多次被调用的“小函数”改为inline函数或者宏实现。


	第五章：其他要求
	5.1 安全性
	代码的安全漏洞大都是由代码缺陷导致，但不是所有代码缺陷都有安全风险。理解安全漏洞产生的原理和如何进行安全编码是减少软件安全问题最直接有效的办法。

	原则：对用户输入进行检查。
	说明：不能假定用户输入都是合法的，因为难以保证不存在恶意用户，即使是合法用户也可能由于误用误操作而产生非法输入。

	5.1.1 字符串操作安全
	规则：确保所有字符串是以NULL结束。
	说明：C语言中“\0”作为字符串的结束符，即NULL结束符。标准字符串处理函数（如strcpy（）、strlen（） ）依赖NULL结束符来确定字符串的长度。没有正确使用NULL结束字符串会导致缓冲区溢出和其它未定义的行为。

	规则：不要将边界不明确的字符串写到固定长度的数组中。
	说明：边界不明确的字符串（如来自gets（）、getenv（）、scanf（）的字符串），长度可能大于目标数组长度，直接拷贝到固定长度的数组中容易导致缓冲区溢出。

	5.1.2 整数安全
	规则：避免整数溢出。
	说明：当一个整数被增加超过其最大值时会发生整数上溢，被减小小于其最小值时会发生整数下溢。 带符号和无符号的数都有可能发生溢出。

	规则：避免符号错误。
		示例：错误示例

	规则：避免截断错误。

	5.1.3 格式化输出安全
	规则：确保格式字符和参数匹配。
	示例：错误示例

	规则：避免将用户输入作为格式化字符串的一部分或者全部。

	5.1.4 文件I/O安全
	规则：避免使用strlen()计算二进制数据的长度。
		说明：strlen()函数用于计算字符串的长度，它返回字符串中第一个NULL结束符之前的字符的数量。因此用strlen()处理文件I/O函数读取的内容时要小心，因为这些内容可能是二进制也可能时文本。
	示例：错误示例
		正确做法：在不能确定从文件读取到的数据的类型时，不要使用依赖NULL结束符的字符串操作函数。
	示例：
	规则：使用int类型变量来解释字符I/O函数的返回值。
	说明：字符I/O函数fgetc()、getc()和getchar()都从一个流读取一个字符，并把它以int值的形式返回。如果这个流到达了文件尾或者发生读取错误，函数返回EOF。fput()、putc()、putchar()和ungetc()也返回一个字符或EOF。
	如果这些I/O函数的返回值需要与EOF进行比较，不要将返回值转换为char类型。因为char是有符号8位的值，int是32位的值。如果getchar()返回的字符的ASCII值为0xFF，转化为char类型后将被解释为EOF。因为这个值被有符号扩展为0xFFFFFFFF(EOF的值)执行比较。
	示例：错误示例


	5.1.5 其他
	规则：防止命令注入
		说明：C99函数system()通过调用一个系统定义的命令解析器来执行一个指定的程序/命令。如果system()的参数有用户的输入组成，恶意用户可以通过构造恶意输入，改变system()调用的行为。

	5.2 可测性
	原则：模块划分清晰，接口明确，耦合性小，有明确的输入和输出，否则单元测试实施困难。
	规则：调测打印的日志要有统一的规定。
	规则：使用断言记录内部假设。
	规则：不能用断言来检查运行时错误。

	5.3 可移植性
	规则：不能定义、重复定义或取消标准库/平台中保留的标识符、宏和函数。
	建议：不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。
	建议：除非为了满足特殊需求，避免使用嵌入式汇编。


	第六章：C++特性
	6.1 常量
	规则：使用const常量取代宏。
	说明：宏是简单的文本替换，在预处理阶段时完成，运行报错时直接报相应的值；跟踪调试时也是显示值，而不是宏名；宏没有类型检查，不安全；宏没有作用域。
	示例：

	规则：一组相关的整型常量应定义为枚举。
	说明：之所以使用枚举，基于：枚举比#define或const  int更安全，因为编译器会检查参数值是否位于枚举取值范围内，从而避免错误发生。
	示例：
	程序内部使用，仅用于分类的情况，不应该进行显式的赋值。当枚举值需要对应到具体数值时，须在声明时显示赋值。否则不需要显式赋值，以避免重复赋值，降低维护(增加、删除成员)工作量。
	应当尽量避免枚举值重复，如必须重复也要用已定义的枚举来修饰。
	示例：

	规则：不相关的常量，即使取值一样，也必须分别定义。
	说明：一个常量只用来表示一个特定功能，即一个常量不能有多种用途。
	示例：

	建议：尽可能使用const。
	说明：在声明的变量或参数前加上关键字const用于指明变量值不可被篡改。类成员函数加上const限定符表明该函数不会修改类成员变量的状态。
	使用const常见的场景：
		函数参数：传递引用时，如果函数不会修改传入参数，该形参应声明为const。
		成员函数：访问函数(如get函数)；不修改任何数据成员的函数；未调用非const函数、未返回数据成员的非const指针或引用的函数。
		数据成员：如果数据成员在对象构造之后不再发生变化，可将其定义为const。

	6.2 初始化和类型转换
	6.2.1 说明、定义与初始化
	规则：禁止用memcpy、memset初始化非POD对象。
	说明：POD全称是“PlainOldData”，是C++98标准(ISO/IEC14882，firstedition，1998-09-01)中引入的一个概念，POD类型主要包括int，char，float，double，enumeration，void，指针等原始类型及其集合类型。
	由于非POD类型比如非集合类型的class对象，可能存在虚函数，内存布局不确定，跟编译器有关，滥用内存拷贝可能会导致严重的问题。即使对集合类型的class，使用直接的内存拷贝和比较，破坏了信息隐蔽和数据保护的作用，也不提倡memcpy、memset操作。

	建议：变量使用时才声明并初始化。
	说明：变量在使用前未赋初值，是常见的低级编程错误。使用前才声明变量并同时初始化，非常方便地避免了此类低级错误。
	在函数开始位置声明所有变量，后面才使用变量，作用域覆盖整个函数实现，容易导致如下问题：
		程序难以理解和维护：变量的定义与使用分离。
		变量难以合理初始化：在函数开始时，经常没有足够的信息进行变量初始化，往往用某个默认的空值(比如零)来初始化，这通常是一种浪费，如果变量在被赋于有效值以前使用，还会导致错误。遵循变量作用域最小化原则与就近声明原则，使得代码更容易阅读，方便了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值。
	示例：

	建议：避免构造函数做复杂的初始化，可以使用“init”函数说明：就像函数的变量都在函数内部初始化一样，类数据成员最好的初始化场所就是构造函数，数据成员都应该尽量在构造函数中初始化。
	说明：以下情况可以使用init()函数来初始化：
		需要提供初始化返回信息。
		数据成员初始化可能抛异常。
		数据成员初始化失败会造成该类对象初始化失败，引起不确定状态。
		数据成员初始化依赖this指针：构造函数没结束，对象就没有构造出来，构造函数内不能使用this成员；
		数据成员初始化需要调用虚函数。在构造函数和析构函数中调用虚函数，会导致未定义的行为。
	示例：

	建议：初始化列表要严格按照成员声明顺序来初始化它们。
	说明：编译器会按照数据成员在类定义中声明的顺序进行初始化，而不是按照初始化列表中的顺序，如果打乱初始化列表的顺序实际上不起作用，但会造成阅读和理解上的混淆；特别是成员变量之间存在依赖关系时可能导致BUG。在成员声明时，应按照成员相互依赖关系按顺序声明。
	示例：

	建议：明确有依赖关系的全局与静态对象的初始化顺序。
	说明：如果全局对象A的成员变量有外部依赖，比如依赖另外一个全局变量B，在A的构造函数中访问B，隐含的规则就是B先于A初始化，然而全局与静态对象的初始化与析构顺序未有严格定义，无法确保B已经完成初始化，而每次生成可执行程序都可能发生变化，这类BUG难以定位。通常采用单件(Singleton)模式或者把有依赖关系的全局对象放在一个文件中定义来明确初始化顺序。
	同一个文件中，若全局对象a在全局对象b之前定义，则a一定会在b之前初始化；但是不同文件中的全局对象就没有固定的初始化顺序。可以在main()或pthread_once()内初始化一个运行期间不回收的指针。

	6.2.2 类型转换
	避免使用类型分支来定制行为：类型分支来定制行为容易出错，是企图用C++编写C代码的明显标志。这是一种很不灵活的技术，要添加新类型时，如果忘记修改所有分支，编译器也不会告知。使用模板和虚函数，让类型自己而不是调用它们的代码来决定行为。

	规则：使用C++风格的类型转换，不要使用C风格的类型转换。
	说明：C++的类型转换由于采用关键字，更醒目，更容易查找，编程中强迫程序员多停留思考片刻，谨慎使用强制转换。
	C++使用const_cast，dynamic_cast，static_cast，reinterpret_cast等新的类型转换，它们允许用户选择适当级别的转换符，而不是像C那样全用一个转换符。
		dynamic_cast：主要用于下行转换，dynamic_cast具有类型检查的功能。dynamic_cast有一定的开销，建议在调测代码中使用。
		static_cast：和C风格转换相似可做值的强制转换，或上行转换(把派生类的指针或引用转换成基类的指针或引用)。该转换经常用于消除多重继承带来的类型歧义，是相对安全的。下行转换(把基类的指针或引用转换成派生类的指针或引用)时，由于没有动态类型检查，所以不安全的，不提倡下行转换。
		reinterpret_cast：用于转换不相关的类型。reinterpret_cast强制编译器将某个类型对象的内存重新解释成另一种类型，相关代码可移植不好。建议对reinterpret_cast<>的用法进行注释，有助于减少维护者在看到这种转换时的顾虑。
		const_cast：用于移除对象的const属性，使对象变得可修改。
	示例：

	建议：避免使用reinterpret_cast。
	说明：reinterpret_cast用于转换不相关类型。尝试用reinterpret_cast将一种类型强制转换另一种类型，这破坏了类型的安全性与可靠性，是一种不安全的转换。不同类型之间尽量避免转换。

	建议：避免使用const_cast。说明：const_cast用于移除对象的const性质。
	const属性提供一种安全感，让程序员知道这个定义是固定不变的，从而不需要担心后面的变化。如果const属性在程序员不知道的地方被消除，会带来很多严重的后果。
	示例：

	建议：使用虚函数替换dynamic_cast。
	说明：很多刚从C语言转过了的程序员习惯这样的思路：若对象的类型是T1，则做某种处理；若对象的类型是T2，则做另外的处理等等。但C++提供了更好的解决方案：虚函数。
	虚函数与dynamic_cast类型转换相比：
		虚函数更安全，不会出现强制转换错的情况；
		虚函数效率更高：用函数指针，避免条件判断；
		虚函数不需要在编码时确定对象的真实类型，而dynamic_cast必须告知要转成的类型，运行时若类型不当返回空指针或者抛异常；
		虚函数适用性更强：虚函数是真正动态绑定；类型转换当增加或删除一个派生类时，dynamic_cast必须增减相应的代码。

	6.3 函数
	6.3.1 内联函数
	规则：内联函数小于10行。
	说明：内联函数具有一般函数的特性，它与一般函数不同之处只在于函数调用的处理。一般函数进行调用时，要将程序执行权转到被调用函数中，然后再返回到调用它的函数中；而内联函数在调用时，是将调用表达式用内联函数体来替换。内联函数只适合于只有1～10行的小函数。对一个含有许多语句的大函数，函数调用和返回的开销相对来说微不足道，也没有必要用内联函数实现，一般的编译器会放弃内联方式，而采用普通的方式调用函数。如果内联函数包含复杂的控制结构，如循环、分支(switch)、try-catch等语句，一般编译器将该函数视同普通函数。虚函数、递归函数不能被用来做内联函数。

	规则：使用内联函数代替函数宏。
	说明：C++中也支持宏的功能，但是宏有其自身固有的缺陷(例如无法对参数进行类型检查)，因此，能使用内联函数的地方，一定不使用宏。
	例外：一些通用且成熟的应用，如：对new，delete的封装处理，可以保留对宏的使用。

	建议：内联函数应该放在头文件中声明，而且在函数前添加inline关键字。
	说明：内联函数的定义对编译器而言必须可见，以便在调用点将函数展开。放在头文件中可以保证对编译器可见，修改或者删除内联函数时，重新编译使用该头文件的所有源文件。


	6.3.2 函数参数
	建议：入参尽量用const引用取代指针。
	说明：引用比指针更安全，因为它一定非空，且一定不会再指向其他目标；引用不需要检查非法的NULL指针。


	建议：消除未使用函数参数。
	说明：检查未使用的函数参数，确认是否需要使用该函数参数，如果不需要直接删除参数名。当实现接口时，有一些参数没有被引用是相当常见的。编译器会发现未使用的参数，并产生一个警告，有些组件甚至会认为这是一个错误。为避免发生如此情况，将未使用的参数使用/*参数名*/语法将其注释掉。

	建议：尽量少用缺省参数。
	说明：使用参数的缺省值仅仅方便函数的使用，没有赋予函数新的功能，但降低函数的可理解。缺省参数使得拷贝粘贴以前函数调用的代码难以呈现所有参数，当缺省参数不适用于新代码时可能导致重大问题。

	6.3.3 函数指针
	建议：尽量少用函数指针。
	说明：不少代码中还是用函数指针来实现一些功能扩展（如封装），但函数指针难以理解和难以维护，建议使用C++中派生与继承的基本用法，少用函数指针。


	6.4 类
	6.4.1类的设计
	类是面向对象设计的基础，一个好的类应该职责单一，接口清晰、少而完备，类间低耦合、类内高内聚，并且很好地展现封装、继承、多态、模块化等特性。

	原则：类职责单一。
	说明：类应该职责单一。如果一个类的职责过多，往往难以设计、实现、使用、维护。随着功能的扩展，类的职责范围自然也扩大，但职责不应该发散。
	用小类代替巨类。小类更易于编写，测试，使用和维护。用小类体现简单设计的概念；巨类会削弱封装性，巨类往往承担过多职责，试图提供“完整”的解决方案，但往往难以真正成功。如果一个类有10个以上数据成员，类的职责可能过多。

	原则：隐藏信息。
	说明：封装是面向对象设计和编程的核心概念之一。隐藏实现的内部数据，减少调用者代码与具体实现代码之间的依赖。
		尽量减少全局和共享数据；
		禁止成员函数返回成员可写的引用或者指针；
		将数据成员设为私有的(struct除外)，并提供相关存取函数；避免为每个类数据成员提供访问函数；
		运行时多态，将内部实现(派生类提供)与对外接口(基类提供)分离。

	原则：尽量使类的接口正交、少而完备。
	说明：应该围绕一个核心去定义接口、提供服务、与其他类合作，从而易于实现、理解、使用、测试和维护。接口函数功能正交，尽量避免一个接口功能覆盖另一个接口功能。接口函数太多，会难以理解、使用和维护。如果一个类包含20个以上的非私有成员函数，类的接口可能不够精简。

	规则：模块间对外接口类不要暴露私有和保护成员。
	说明：对外接口类暴露受保护或者私有成员则破坏了封装，一旦因为类的设计变更(增加，删除，修改内部成员)会导致关联组件或系统的代码重新编译，从而增加系统编译时间，也产生了二进制兼容问题，导致关联升级和打补丁。所以除非必要，不要在接口类中暴露私有和保护成员。
	有如下几种做法：
		使用纯虚类作为接口类，用实现类完成实现，使用者只看到接口类，这种做法缺点是：
	代码结构相对复杂。
	新增接口必须放在原有接口后面，不能改变原有接口的顺序。否则，因为虚函数表的原因，会导致客户代码重新编译。
		接口类使用PIMPL模式(只有一个指向实现类指针的私有数据成员)，所有私有成员都封装在实现类中(实现类可以不暴露为头文件，直接放在实现文件中)。
	代码结构简单，容易理解。可以节省虚函数开销，但是有间接访问开销。
	修改实现不会导致客户代码重新编译。
	示例：

	规则：避免成员函数返回成员可写的引用或者指针。
	说明：破坏了类的封装性，对象本身不知道的情况下对象的成员被修改。
	示例：

	规则：禁止类之间循环依赖。
	说明：循环依赖会导致系统耦合度大大增加，所以类之间禁止循环依赖。类A依赖类B，类B依赖类A。出现这种情况需要对类设计进行调整，引入类C：
	升级：将关联业务提到类C，使类C依赖类A和类B，来消除循环依赖。
	降级：将关联业务提到类C，使类A和类B都依赖类C，来消除循环依赖。
	示例：

	建议：将数据成员设为私有的(struct除外)，并提供相关存取函数。
	说明：信息隐藏是良好设计的关键，应该将所有数据成员设为私有，精确的控制成员变量的读写，对外屏蔽内部实现。否则意味类的部分状态可能无法控制、无法预测，原因是：非private成员破坏了类的封装性，导致类本身不知道其数据成员何时被修改；任何对类的修改都会延伸影响到使用该类的代码。将数据成员私有化，必要时提供相关存取函数，如定义变量foo_及取值函数foo()、赋值操作符set_foo()。存取函数一般内联在头文件中定义成内联函数。如果外部没有需求，私有数据成员可不提供存取函数，以达到隐藏和保护的目的。不要通过存取函数来访问私有数据成员的地址(见规则：避免成员函数返回成员可写的引用或者指针)。

	建议：使用PIMPL模式，确保私有成员真正不可见。
	说明：C++将私有成员成员指定为不可访问，但还是可见的，可以通过PIMPL惯用法使私有成员在当前类的范围中不可见。PIMPL主要是通过前置声明，达到接口与实现的分离的效果，降低编译时间，降低耦合。
	示例：

	6.4.2 构造、赋值和析构
	规则：包含成员变量的类，须定义构造函数或者默认构造函数。
	说明：如果类有成员变量，没有定义构造函数，又没有定义默认构造函数，编译器将自动生成一个构造函数，但编译器生成的构造函数并不会对成员变量进行初始化，对象状态处于一种不确定性。
	例外：如果这个类是从另一个类继承下来，且没有增加成员变量，则不用提供默认构造函数
	示例：

	规则：为避免隐式转换，将单参数构造函数声明为explicit。
	说明：单参数构造函数如果没有用explict声明，则会成为隐式转换函数。
	示例：

	规则：包含资源管理的类应自定义拷贝构造函数、赋值操作符和析构函数。
	说明：如果用户不定义，编译器默认会生成拷贝构造函数、赋值操作符和析构函数。自动生成的拷贝构造函数、赋值操作符只是将所有源对象的成员简单赋值给目的对象，即浅拷贝(shallowcopy)；自动生成析构函数是空的。这对于包含资源管理的类来说是不够的：比如从堆中申请的资源，浅拷贝会使得源对象和目的对象的成员指向同一内存，会导致资源重复释放。空的析构函数不会释放已申请内存。如果不需要拷贝构造函数和赋值操作符，可以声明为private属性，让它们失效。

	规则：在operator=中检查给自己赋值的情况。
	说明：自己给自己赋值和普通赋值有很多不同，若不防范会出问题。
	示例：
	规则：在拷贝构造函数、赋值操作符中对所有数据成员赋值。
	说明：确保构造函数、赋值操作符的对象完整性，避免初始化不完全。

	规则：通过基类指针来执行删除操作时，基类的析构函数设为公有且虚拟的。
	说明：只有基类析构函数是虚拟的，才能保证派生类的析构函数被调用。
	示例：

	规则：避免在构造函数和析构函数中调用虚函数。
	说明：在构造函数和析构函数中调用虚函数，会导致未定义的行为。在C++中，一个基类一次只构造一个完整的对象。
	示例：

	建议：拷贝构造函数和赋值操作符的参数定义成const引用类型。
	说明：拷贝构造函数和赋值操作符不可以改变它所引用的对象。

	建议：在析构函数中集中释放资源。
	说明：使用析构函数来集中处理资源清理工作。如果在析构函数之前，资源被释放（如release函数），请将资源设置为NULL，以保证析构函数不会重复释放。

	6.4.3 继承
	原则：用组合代替继承。
	说明：继承和组合都可以复用和扩展现有的能力。如果组合能表示类的关系，那么优先使用组合。
	继承实现比较简单直观，但继承在编译时定义，无法在运行时改变；继承对派生类暴露了基类的实现细节，使派生类与基类耦合性非常强。一旦基类发生变化，派生类随着变化，而且因为派生类无法修改基类的非虚函数，导致修改基类会影响到各个派生类。
	而组合的灵活性较高，代码耦合小，所以优先考虑组合。
	但是并非绝对，往往组合和继承是一起使用的，例如组合的元素是抽象的，通过实现抽象来修改组合的行为。
	继承在一般情况下有两类：实现继承 (implementation inheritance) 和接口继承 (interface inheritance) ，尽可能不要使用实现继承而考虑用组合替代。接口继承：只继承成员函数的接口（也就是声明），例如纯虚（ pure virtual ）函数；实现继承：继承成员函数的接口和实现，例如虚函数同时继承接口和缺省实现，又能够覆写它们所继承的实现；非虚函数继承接口，强制性继承实现。
	示例：

	原则：避免使用多重继承。
	说明：相比单继承，多重实现继承可重用更多代码；但多重继承会显著增加代码的复杂性，程序可维护性差，且父类转换时容易出错，所以除非必要，不要使用多重实现继承，使用组合来代替。多重继承中基类都是纯接口类，至多只有一个类含有实现。

	规则：使用public 继承而不是 protected/private 继承。
	说明： public 继承与 private 继承的区别：
		private 继承体现 " 由... 来实现 " 的关系。编译器不会把 private 继承的派生类转换成基类， 也就是说，私有继承的基类和派生类没有 " 是... 一个" 的关系。
		public 继承体现 " 是... 一个" 的关系，即类 B public 继承于类 A，则B的对象就是 A的对象，反之则不然。例如“白马是马，但马不是白马”。

	对继承而言，努力做到 " 是... 一个" 的关系，否则使用组合代替。private 继承意味 " 由... 来实现 " ，它通常比组合的级别低，与组合的区别：
		private 继承可以访问基类的 protected 成员，而组合不能。
		private 继承可以重新定义基类的虚函数，而组合不能。
	尽量用组合代替 private 继承，因为 private 继承不如组合简单直观，且容易和 public 继承混淆。

	规则：继承层次不超过4层。
	说明：当继承的层数超过4层时，对软件的可维护性大大降低，可以尝试用组合替代继承。

	规则：虚函数绝不使用缺省参数值。
	说明：在C++中，虚函数是动态绑定的，但函数的缺省参数却是在编译时就静态绑定的。这意味着你最终执行的函数是一个定义在派生类，但使用了基类中的缺省参数值的虚函数。因此只要在基类中定义缺省参数值即可，绝对不要在派生类中再定义缺省参数值。
	示例 ：

	规则：绝不重新定义继承而来的非虚函数。
	说明：因为非虚函数无法实现动态绑定，只有虚函数才能实现动态绑定：只要操作基类的指针，即可获得正确的结果。
	示例：

	建议：避免派生类中定义与基类同名但参数类型不同的函数。
	说明：参数类型不同的函数实际是不同的函数。

	建议：派生类重定义的虚函数也要声明virtual关键字。
	说明：当重定义派生的虚函数时，在派生类中明确声明其为virtual。如果遗漏virtual声明，阅读者需要检索类的所有祖先以确定该函数是否为虚函数。

	6.4.4 重载
	C++的重载功能使得同名函数可以有多种实现方法，以简化接口的设计和使用。但是，要合理运用防止带来二义性以及潜在问题。保持重载操作符的自然语义，不要盲目创新。

	原则：尽量不重载操作符，保持重载操作符的自然语义。
	说明：重载操作符要有充分理由，而且不要改变操作符原有语义，例如不要使用‘+’操作符来做减运算。操作符重载令代码更加直观，但也有一些不足：
	混淆直觉，误以为该操作和内建类型一样是高性能的，忽略了性能降低的可能；
	问题定位时不够直观，按函数名查找比按操作符显然更方便。
	重载操作符如果行为定义不直观(例如将‘+’操作符来做减运算)，会让代码产生混淆。
	赋值操作符的重载引入的隐式转换会隐藏很深的bug。可以定义类似Equals()、CopyFrom()等函数来替代=，==操作符。

	规则：仅在输入参数类型不同、功能相同时重载函数。
	说明：使用重载，导致在特定调用处很难确定到底调用的是哪个函数；当派生类只重载函数的部分变量，会对继承语义产生困惑，造成不必要的费解。
	如果函数的功能不同，考虑让函数名包含参数信息，例如，使用AppendName()、AppendID()而不是Append()。

	建议：使用重载以避免隐式类型转换。
	说明：隐式转换常常创建临时变量；如果提供类型精确匹配的重载函数，不会导致转换。
	示例：


	6.5 作用域、模板和C++其他特性
	6.5.1 作用域
	规则：不要在头文件中或者#include之前使用using指示符。
	说明：使用using会影响后续代码，易造成符号冲突，所以不要在头文件以及源文件中的#include之前使用using。
	示例：

	建议：尽量少使用嵌套类。
	说明：一个类在另一个类中定义，这样的类被称为嵌套类。嵌套类是其外围类的成员，嵌套类也被称为成员类。
	示例；
	跟其它类一样，嵌套类可以声明为public、priate和protected属性，因此，从外部访问嵌套类，遵循类成员的访问规则。
	一般来说，应该尽量少用嵌套类。嵌套类最适合用来对它们的外层类实现细节建模(如：方便实现链表、容器等算法)，且在这个类需要访问外围类所有成员(包括私有成员)时才使用嵌套类。不要通过嵌套类来进行命名分组，应该使用名字空间。

	建议：尽可能不使用局部类。
	说明：定义在函数体内的类称为局部类。局部类只在定义它的局部域内可见。
	局部类的成员函数必须被定义在类定义中，且不能超过15行代码。否则，代码将变得很难理解。建议：使用静态成员函数或名字空间内的非成员函数，避免使用全局函数。说明：非成员函数放在名字空间内可避免污染全局作用域。
	如果你必须定义非成员函数，又只是在.cpp文件中使用它，也可使用static关键字(如staticintFoo(){...})限定其作用域。建议：避免class类型的全局变量，尽量用单件模式。说明：静态生存周期的对象，包括全局变量，静态变量，静态类成员变量，以及函数静态变量，都必须是原生数据类型(POD:PlainOldData)。
	静态变量的构造函数，析构函数以及初始化操作的调用顺序在C++标准中未明确定义，从而导致难以发现的bug。比如作用域结束时，某个静态变量已经被析构了，但其他代码还试图访问该变量，导致系统崩溃。所以只允许POD类型的静态变量。同样，不允许用函数返回值来初始化静态变量。


	6.5.2 模板
	模板可以衍生出一系列的类和函数，这是一种形式的代码复用。但要注意，这种形式的复用是源代码级而不是目标代码级的。也就是说，对模板的每一次实例化都会产生一份新的源代码。与此相反，继承允许复用基类的大部分目标代码。
	滥用模板会造成三个后果：第一，代码规模的过度膨胀；第二，当修改模板时，很难预料是否会对原先正常工作的代码造成不良影响；第三，很难确保模板所有可能的合法实例化都能正常工作。所以模板的使用要仔细且有节制。

	建议：谨慎使用模板，只使用模板的基础特性。
	说明：模板对编译器的要求很高，当前对模板100%支持的编译器几乎没有，因此，使用前应作测试，特别是涉及偏特化，模板参数等高级特性时。
	模板的错误提示比较难懂，产生的错误要映射回模板后才能显示给编程者看，但映射毕竟不是错代码本身，所以有时很难看懂，有时甚至失真，对于人员素质要求也高，增加了维护难度。

	建议：注意使用模板的代码膨胀。
	说明：模板会为每个类型产生一个实例，如果使用不当，会产生过多实例，特别是根据常量实例化时。

	建议：模板类型应该使用引用或指针。
	说明：实例化和参数传递复杂类型(结构体，对象)，传值的代价很高；引用和指针可以提高效率。

	建议：模板如果有约束条件，请在模板定义处显式说明。
	说明：编译对模板的检查较弱，很难保证检察所有错误，因此进行显式说明可以减少模板使用错误。

	建议：两个模块之间接口中尽量不要暴露模板。
	说明：因为在编译器优化选项打开的情况下，其编译的符号为不确定，导致依赖。

	6.5.3 其他
	建议：避免使用友元。
	说明：友元扩大了(但没有打破)类的封装边界。友元会导致类间强耦合，打破封装，暴露出具体实现，从而使友元和类的实现紧耦合；友元不可继承，降低可继承性。
	例外：某些情况下，相对于将类成员声明为public，使用友元是更好的选择，尤其是你只允许另一个类访问该类的私有成员时。

	建议：避免使用RTTI。
	说明：RTTI允许在运行时识别对象的类型。使用RTTI很容易违反“开放封闭原则”。如果要根据派生类的类型来确定执行不同逻辑代码，虚函数无疑更合适，在对象内部就可以处理类型识别问题；如果要在对象外部的代码中判断类型，考虑使用双重分派方案，如访问者模式，在对象本身之外确定类的类型。所以，不建议使用RTTI，除非在一些特定场合如某些单元测试中会用到。

	建议：使用sizeof(变量)而不是sizeof(类型)。
	说明：使用sizeof(varname)，当代码中变量类型改变时会自动更新。
	示例：
	另外，对数组来说，sizeof(数组变量)并不一定是元素的个数，元素个数是sizeof(数组变量)/sizeof(数组变量[0])。


	6.6 资源分配和释放
	原则：明确产品动态内存的申请与释放原则。
	说明：之所以存在大量内存问题，主要原因是申请与释放内存的规则混乱：
		申请内存后，传入子程序中，由子程序使用并释放；
		由子程序申请内存并返回父程序，层层调用后在某一个函数内释放。

	内存申请与释放一般原则：
		对象在退出其作用域时，就应该立即被释放，而且要做到：谁申请，谁释放。
		函数内分配的内存，函数退出之前要释放，避免跨函数释放；
		类中数据成员的内存，在析构函数中确认并释放；
		全局变量、静态变量的内存空间则在进程退出时，或相应的共享库被卸载时，由操作系统回收；
		如果程序分支很多或内存资源的分配与释放不在同一个地方，要考虑使用RAII等资源跟踪管理技术。

	规则：明确operator  new的行为和检查策略。
	说明：当operator  new无法满足某一内存分配需求时，默认会抛异常，也可以返回空指针(通过编译选项设置)。团队明确operator  new的操作。在申请内存后，要立即检查指针是否为NULL或进行异常处理。
	示例：捕获异常来处理申请内存失败情况。
	或进行非空判断：
	示例：

	规则：释放内存后，要立即将指针设置为NULL，防止产生野指针。
	说明：free或delete释放内存后，立即将指针设置为NULL，防止产生“野指针”。这种判断最好能够封装起来，见建议：避免在不同的模块中分配和释放内存。
	示例：

	规则：单个对象释放使用delete，数组对象释放使用delete[]。
	说明：单个对象删除使用delete，数组对象删除使用delete[]，原因：
	调用new所包含的动作：从系统中申请一块内存，若是对象调用相应的构造函数。
	调用new[n]所包含的动作：申请可容纳n个对象外加一点内存来保存数组的元素的数量；调用n次构造函数初始化这块内存中的n个对象。
	调用delete所包含的动作：若是对象调用相应的析构函数；将内存归还系统。
	调用delete[]所包含的动作：从new[]将找出的n值；调用n次相应的析构函数；将内存归还给系统。
	示例：

	规则：释放结构(类)指针时，首先释放其成员指针的内存空间。
	示例：

	规则：释放指针数组时，首先释放数组每个元素指针的内存。
	说明：在释放指针数组时，确保数组中的每个元素指针是否已经被释放了，这样才不会导致内存泄漏。

	规则：不要返回局部对象指针。
	说明：局部对象在定义点构造，在同一作用域结束时立即被销毁。
	示例：

	规则：不要强制关闭线程。
	说明：线程被强制关闭，导致线程内部资源泄漏。用事件或信号量通知线程，确保线程调用自身的退出函数。线程死锁需要强制关闭的情况除外。

	建议：使用new，delete的封装方式来分配与释放内存。
	说明：推荐使用如下宏，可以在一定程度上避免使用空指针，野指针的问题。
	示例：
	建议：避免在不同的模块中分配和释放内存。
	说明：在一个模块中分配内存，却在另一个模块中释放它，会使这两个模块之间产生远距离的依赖，使程序变得脆弱。
	模块在C++是一个不清晰的概念，小到一个类，大到一个库。如果在不同的类之间分配、释放内存，需要考虑两个类的初始化、销毁顺序；如果在不同的库之间分配、释放内存，需要考虑两个库的加载或卸载顺序。这种远距离的依赖，容易导致遗漏和重复操作，引发严重问题。应遵循“谁申请、谁释放”的原则。为了降低处理复杂性，可以适当地采用RAII或智能指针。

	建议：使用RAII特性来帮助追踪动态分配。
	说明：RAII是“资源获取就是初始化”的缩语(ResourceAcquisitionIsInitialization)，是一种利用对象生命周期来控制程序资源(如内存、文件句柄、网络连接、互斥量等等)的简单技术。RAII的一般做法是这样的：在对象构造时获取资源，接着控制对资源的访问使之在对象的生命周期内始终保持有效，最后在对象析构的时候释放资源。这种做法有两大好处：
	我们不需要显式地释放资源。
	对象所需的资源在其生命期内始终保持有效。这样，就不必检查资源有效性的问题，可以简化逻辑、提高效率。
	boost库中提供了一种新型的智能指针shared_ptr，它解决了多个指针间共享对象所有权的问题，同时也满足容器对元素的要求，因而可以安全地放入容器中。shared_ptr解决了auto_ptr移动语义的破坏性。
	关于auto_ptr与shared_ptr使用请参考C++标准库的相关书籍。
	示例：使用RAII不需要显式地释放互斥资源。


	6.7 异常与错误处理
	6.7.1 异常
	异常是C++语言的一个强大特性，在正确使用之前需要深入了解，以及使用异常代码的上下文。

	原则：减少不必要的异常。
	说明：异常对编码技能要求更高，使用中容易出错，首先从安全性角度考虑，尽量少用或者不用异常。相比返回错误，异常的优点：
		异常可以集中捕捉，错误检测与算法处理相分离，算法逻辑更清晰；而返回错误在每个返回点都要进行检测与错误处理，代码逻辑分散。
		异常的约束更强，用户不能忽略抛出的异常，否则程序默认会被终止，而返回错误则可能被忽略。
	异常的缺点也很明显：
		必须检查所有调用点是否可能抛出异常，在抛出后必须正确处理状态和资源变量等，否则可能导致对象状态不正确或者资源泄露等。例如：如果f()依次调用了g()和h()，h抛出被f捕获的异常，g就要当心了，避免资源泄露。
		必须清楚可能抛出的所有异常，并在合适的地方捕捉，如果遗漏通常会导致程序被终止。
		使用异常很难评估程序的控制流，代码很难调试。
		目标文件变大，编译时间延长，性能下降。
	若对异常缺乏充分理解，可能会在不恰当的时候抛出异常，或在不安全的地方从异常中恢复。
	适用异常的几个场景：
		出现“不应该出现的”失败，且不能被忽略必须处理，比如分配内存失败。
		上层应用决定如何处理在底层嵌套函数中“不可能出现的”失败。
		错误码难以通过函数的返回值或参数返回，比如流。
		许多第三方C++库使用异常，必须在系统边界与第三方C++库结合处使用异常便于跟这些库集成。在测试框架中使用异常很方便。

	规则：构造和析构函数不能抛出异常。
	说明：如果构造和析构函数执行失败则无法安全地撤销和回滚，故这些函数不能向外抛出异常。为了降低复杂性，建议在这类函数中实现最简单的逻辑。

	规则：通过传值的方式抛出，通过引用的方式捕获。
	说明：抛出异常时，如果抛出指针，谁释放指针就成为问题。捕捉时如果是传值，会存在拷贝，拷贝可能不成功(比如异常是由于内存耗尽造成的)，而且拷贝得不到派生类对象，因为在拷贝时，派生类对象会被切片成为基类对象。

	规则：确保抛出的异常一定能被捕捉到。
	说明：异常未被捕捉到，系统的默认行为是终止程序运行，所以要确保程序产生的异常都能被捕捉。

	规则：确保异常发生后资源不泄漏。
	说明：异常发生后，当前代码执行序列被打断，需要查看分配的内存、文件和内核句柄等资源是否正确释放，避免资源泄漏，尤其每个可能的返回点是否正确释放资源。

	规则：独立编译模块或子系统的外部接口禁止抛异常。
	说明：异常处理没有普遍通用的二进制标准，所以不允许跨模块抛异常。

	6.7 并发
	规则：多线程、进程并行访问共享资源时，一定要加锁保护。
	说明：共享资源包括全局变量，静态变量，共享内存，文件等。建议封装像智能指针一样的对象对锁进行管理，比如我们就封装了一个auto_lock，在构造时申请锁，析构中释放锁，保证不会忘记“解锁”。如果锁的作用范围有限，则可以这样：
	示例：

	规则：锁的职责单一。
	说明：每个锁只锁一个唯一共享资源；这样，才能保证锁应用的单一，也能更好的确保加锁的范围尽量小。
	对于共享全局资源，应该根据实际需要，每类或每个资源，有一把锁。这样，这把锁只锁对这个资源访问的代码，通常这样的代码都会是比较简单的资源操作代码，不会是复杂的函数调用等。相反，如果我们对几类或几个资源共用一把锁。这把锁的责任范围就大了，使用复杂，很难理清锁之间的关系(有没有释放锁，或者锁之间的嵌套加锁等)，容易导致死锁问题。

	规则：锁范围尽量小，只锁对应资源操作代码。
	说明：使用锁时，尽量减少锁的使用范围。我们使用锁，为了方便，会大范围的加锁，如：直接锁几个函数调用。这种使用，一方面会导致多线程执行效率的低下，容易变成串行执行；另一方面，容易出现锁未释放，或者锁的代码中再加锁的场景，最后导致死锁。
	所以，对锁操作的最好办法，就是只锁简单资源操作代码。对应资源访问完后，马上释放锁。尽量在函数内部靠近资源操作的地方加锁而不是靠近线程、函数外部加锁。

	规则：避免嵌套加锁；如果必须加锁，务必保证不同地方的加锁顺序是一样的。
	说明：加上一把锁之后，在释放之前，不能再加锁。典型的锁中加锁的场景：OMU代码中对几个容器的同时遍历，每个容器一把锁，就导致需要加多把锁。这种场景的解决方法：先加一把锁，对一个容器遍历，选择出合乎要求的数据，并保存在临时变量中；再加另一把锁，使用临时变量，再对其他容器遍历。
	锁中加锁，必须保证加锁的顺序是一样的，比如先加的锁后解锁，
	Lock1
	Lock2
	Unlock2
	Unlock1
	则其他地方的加锁顺序，必须与这里的顺序一样，避免死锁，不允许出现：
	lock2
	lock1
	unlock2
	unlock1

	建议：进程间通讯，使用自己保证互斥的数据库系统、共享内存，或socket消息机制；尽量避免使用文件等进程无法管理的资源。
	说明：由于文件在不同进程间访问，无法保证互斥。当然，可以在进程间加进程锁，但只受限于我们能加锁的进程，对于第三方进程等无法保证。这样，当多个进程同时对文件进行写操作时，将会导致文件数据破坏，或文件写失败等问题。
	当数据库系统本身的访问接口带有互斥机制，当多个进程同时访问时，可以保证数据库数据的完整。共享内存，只限制于使用共享内存的几个进程，需要我们对这些访问共享内存的进程加锁。但由于共享内存，第三方进程等无法访问，这也能比较好的保护数据，避免文件系统存在的问题。socket消息机制，由操作系统socket通讯机制保证互斥，在多个进程间，通过消息来保证数据的互斥。进程的消息都是操作系统转发而来的独立数据，属于进程私有数据，不存在进程间并行访问的问题。

	建议：可重入函数尽量只使用局部变量和函数参数，少用全局变量、静态变量。
	说明：支持多线程并行访问的函数称之为可重入函数。设计可重入函数时，尽量使用局部变量和函数参数来传递数据，在多线程并行访问时，互相之间不会受影响。相反，如果使用全局变量、静态变量，就需要同步。
	示例：
	引申：一些库函数也是非线程安全，调用时可能会出现多线程并发访问问题。

	建议：锁中避免调用函数；如果必须调用函数，务必保证不会造成死锁。
	说明：这条规则是对加锁范围尽量小(只锁对应资源操作代码)规则的补充。不能把调用函数也加到加锁范围中。因为被调用函数的内部到底做了什么事情，是如何做的，调用者可能不是很清楚。尤其是当被调用函数内部又加锁的情况，就容易导致两个锁互饿，导致死锁。
	示例：
	当上述线程函数 Thread_func1() 和Thread_func2() 并行执行时，就很有可能导致死锁。而且这种死锁情况还是比较难分析。因为我们调用函数，很多时候只关注函数实现的功能，而忽略函数内部的具体实现。其次，锁中调用函数，也会把对资源操作的代码扩大化，不利于并行效率。更主要的是，这种操作，由于加锁的范围变大，引起死锁的可能就增大。

	建议：锁中避免使用跳转语句。
	说明：跳转语句包含return、break、continue、goto等。如果锁中有宏调用的代码，要特别注意，分析宏中是否存在隐含的跳转语句。在函数返回时忘记把锁释放，特别是存在很多分支都可能返回的时候，可能一些分支会忘记释放锁。

	6.8 可移植性(兼容性) 
	本章讨论C++可移植性问题主要关注：32位移植到64位，不同CPU架构之间的移植。
	移植中一些关键问题如下：
	1.指针截断
	2.数据类型字节对齐
	3.对内存地址的错误假设
	4.对复合数据类型成员地址的错误假设
	5.大小端，网络字节序问题

	建议：不直接使用C++的基本数据类型，不要假定其存储尺寸长度。
	说明：C++标准没有明确基本数据类型的大小与存储格式，这些基本类型包括：short，int，long，longlong，floatdouble等。这些基本数据类型在不同的编译器中，实现有所不同，如：long类型在32位编译模式下为4字节长度，在64位编译模式下为8字节长度。
	所以建议不要直接使用基本数据类型。推荐如下两种使用方式：
	1、重定义基本数据类型
	示例：
	使用重定义后的基本类型好处是：如果程序需要移植，可以大大减少移植的工作量。
	2、使用C99标准中定义的标准类型
	示例：
	使用这些标准类型长度的好处是，它们规定了固定的长度，这个长度不会随编译器变化而变化，所以我们可以放心的使用。

	建议：避免指针截断。
	说明：指针截断是从32位移植到64位系统时，经常会碰到的问题。

	建议：注意数据类型对齐问题。
	说明：需要对结构对齐加以留心，尤其是对于存储在磁盘上的结构体。
	在64位系统中，任何拥有int64_t/uint64_t成员的类/结构体将默认被处理为8字节对齐。如果32位和64位代码共用磁盘上的结构体，需要确保两种体系结构下的结构体的一致对齐。另外，大多数编译器提供了调整结构体对齐的方案：
	gcc中可使用__attribute__((packed))，MSVC提供了#pragmapack()和__declspec(align())。由于各个平台和编译器的不同，所以在不同编译器与平台移植代码时，一定要特别关注编译器关于对齐的参数设置与默认值。因为字节对齐不仅影响性能，而且会导致一些不可预知的问题。

	建议：在涉及网络字节序处理时，要注意进行网络字节序与本地字节序的转换。
	说明：小端法(Little-Endian)低位字节排放在内存的低地址端即起始地址，高位字节排放在内存的高地址端。大端法(Big-Endian)高位字节排放在内存的低地址端即起始地址，低位字节排放在内存的高地址端。
	同cpu平台上字节序通常也不一样：
	X86、AMD64平台使用小端法、而HP-IA，IBMAIX的CPU采用的是大端法。而网络字节序是大端法，如常见网络发送的码流。
	涉及网络字节需要注意处理网络字节序与本地字节序的转换，即使本地字节序采用的也是大端法，为了程序可移植性，建议也调用转换函数进行转换。
	库函数提供了16，32位整型int的网络字节序与本地字节序的转换函数：
	示例：

	建议：避免无符号数与有符号数的转换。
	说明：不同的国际标准(ANSIC/ISOC++等)对隐式转换有符号和无符号类型的规则不同，有可能导致不同的执行结果。

	建议：创建64位常量时使用LL或ULL作为后缀。
	说明：指定LL或ULL后缀说明，能让代码更加清晰。

	建议：区分sizeof(void*)和sizeof(int)。
	说明：64位下sizeof(void*)!=sizeof(int)，而在32位下是相同的。如果需要一个指针大小的整数请使用intptr_t。

	建议：编译器，操作系统相关的代码独立出来。
	说明：为了程序的可移植性，建议将编译器，操作系统相关的代码从产品代码中独立出来。编译器特有的东西，如gcc的编译参数__thread，__attribute__等，如果需要做到支持多个平台，需要封装为宏或函数。


	书籍推荐
	业界编程规范《googleC++codestyle》(googleC++编程指南)google对外公布的一份google内部编写C++的代码规范文档。Google开发者认为C++是一门包含大量高级特性的巨型语言，某些情况下，他们会限制甚至禁止使用某些特性，使代码简化，避免可能导致的各种问题。包含的内容：头文件、命名规则、注释、语言特性的使用规则、编码格式，等等。特点：强调理解基础上的遵循，一个规则通常明确说明其优点、缺点，并举很多例子，让读者在理解的基础上遵循，不像规章制度那样生硬和抽象，实际上读起来更像一个教程。比如：禁止使用C++异常，花了一页纸的篇幅来解释使用和不使用的优缺点，非常容易理解。
	《C++编程规范101条规则、准则与最佳实践》这本编程规范凝聚两位知名的C++专家(萨特，(HerbSutter)曾任ISOC++标准委员会主席；亚历山德雷斯库(AndreiAlexandrescu)世界顶尖的C++专家)，以及全球C++界20年的集体智慧和经验。
	MicrosoftAll-In-OneCodeFramework《微软一站式示例代码库》微软一站式示例代码库(MicrosoftAll-In-OneCodeFramework)由微软社区技术支持团队倾力呈现，根据MSDN论坛、热门社交网络、多个开发者社区收集的开发者最关心和最烦恼的问题，编写相应的代码示例，并以很短的周期发布更新，以方便开发者下载参考。通过这些示例代码，帮助社区开发者提高开发效率，减少代码中可能出现的bug，并增强代码的可维护性。强调高质量代码示例所具有的特质:1.易懂；2.正确性；3.一致性；4.流行性；5.可靠性；6.安全性。包含内容：1、通用编程规范–对代码风格，格式和结构提供了全局通用的指导；2、C++编程规范；3.NET编码规范。14.2扩展学习材料本规范涉及到一系列C++语言特性和技术，需要深入学习相关知识。
	推荐学习但不限于以下材料：
	 C++primer作者：C++大师StanleyB.Lippman，C++标准委员会原负责人JoséeLajoie。业界公认的完整涵盖C++标准的权威著作，对基本编程技术，面向对象编程，标准库和泛型编程都有全面的介绍。强调重要的知识点，提醒常见的错误，推荐优秀的编程实践，给出使用提示，和大量来自实战的示例和习题。推荐语：初学者的指南，熟练者的参考书。
	effectiveC++/moreeffectiveC++世界顶级C++大师ScottMeyers成名之作《effectiveC++》(改善程序与设计的55个具体做法)以及续集《moreeffectiveC++》(35个改善编程与设计的有效方法)。被评为影响最深远、最受推崇的书籍之一。读过这本书能够跨越C++重重险阻，迅速提升C++功力，值得反复阅读和体会。书中每一条准则描述一个编写出更好的C++程序的方法，每一个条款的背后都有具体范例支撑。改变旧有的C习惯；内存管理；构造函数，析构函数和Assignment运算符；类与函数的设计和声明；类与函数实现；继承关系和面向对象设计；模板，等等。推荐语：有人说C++程序员可以分成两类，读过EffectiveC++的和没读过的。
	参考推荐读物：《ExceptionalC++》（作者：萨特，也是《C++编程规范101条规则、准则与最佳实践》的作者），可作为进阶读物。
	EffectiveSTLScottMeyers(EffectiveC++和MoreEffectiveC++的作者)的又一大作，揭示总结了的一些关键规则，包括专家们总是采用的做法以及总是避免的做法。重点讲述如何使用STL，共有50条指导原则，在讲述每一条指导原则的时候，ScottMeyers都提供了透彻的分析和深刻的实例，所以读者不仅可以学到要做什么，而且还能够知道什么时候该这样做，以及为什么要这样做。主要包括以下几个方面：
	1、关于选择容器的建议，涉及到的容器有：标准STL容器(例如vector和list)、非标准的STL容器(例如hash_set和hash_map)，以及非STL容器(例如bitset)。
	2、一些改进效率的技术，如何最大程度地提高STL程序的效率。
	《C++设计新思维：:泛型编程与设计模式之应用》，《泛型编程与STL》，作为进阶读物。
	《深度探索C++对象模型》，候捷译。该书专注于C++面向对象程序设计的底层机制，包括结构化、临时对象的生成、封装、继承，以及虚拟——虚拟函数和虚拟继承。帮助程序员了解底层实现，深刻理解C++以及编译器背后的处理，迅速提高编程能力，知其所以然。

