

[TOC]



## 内存模型

	0xFF  _____________________________________________________________

	     |                                                             |

	     |                                                             |

	     |                                                             |

	     |                                                             |

	     |                            Data                             |

	     |                                                             |

	     |                                                             |

	0x10 |_____________________________________________________________|

	     |                                                             |

	     |                            Code                             |

	0x00 |_____________________________________________________________|

								（图一）程序运行时的内存模型



	从简化的计算机的模型来看

	    任务        | 计算机 |        结果

	    in数据  ->  |  处理  |  ->    out数据

	     Data       |  Code  |       Data

		可以把计算机视为一个能完成很复杂计算的计算器。给它输入数据，让它进行计算，然后得到结果。而它的计算过程是由各种程序完成的，各个程序获取输入，按照代码运行，并给出结果。所以在程序运行时，可以将程序使用的内存分为两个部分：Code 和 Data。(事实上比这个模型复杂许多，也跟你所使用的操作系统、编译链等相关。以GCC在Linux的编译的ELF为例，在经过编译和链接之后，程序会被分成多个段，Text、BSS、Data、Symbol table等等)。(个人认为、在学习汇编之后再看C语言就犹如张无忌身怀九阳神功去学太极的场景一样--强推 王爽老师的《汇编语言》)。

		对于单片机的运行而言：可以使用图一中的模型，程序代码通常在内存的低地址出，然后可能会跟着一些静态分配的数据空间(包括已初始化和未初始化的)。除此以外的剩余的空间应该视为动态变化的内存(堆和栈)，堆是在程序运行期间需要主动申请内存是所使用的(通常是手动申请和释放)，而栈更特殊一些，它能完成一些内存自动分配和释放工作，以及在函数之间发生调用时能起到关键作用(数据的入栈和出栈)。



## 预处理

### #include

	将其他文件的内容加载在当前文件中。

```c

// some.h

int Function(void);

static int var;

```

```c

// other.c

#include "some.h"



int main(void)

{

	Function();

	return 0;

}

```

	预处理后得到，注意经过预处理后的 other.c 文件已经可以单独的编译和汇编了，还是还需要链接后才能运行。

```c

// other.c

int Function(void);

static int var;



int main(void)

{

	Function();

	return 0;

}

```



### #define

	宏定义，内容替换

```c

#define MAX_VALUE 	(50)

#define CALLBACK()	someFunction()



int main(void)

{

	int x = MAX_VALUE;

	CALLBACK();

	return 0;

}

```

	预处理后：

```c

int main(void)

{

	int x = (50);

	someFunction();

	return 0;

}

```


## 编译



## 汇编



## 链接

## 关键字
### const

