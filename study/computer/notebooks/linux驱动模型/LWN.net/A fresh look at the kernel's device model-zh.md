## A fresh look at the kernel's device model
May 27, 2015
This article was contributed by Neil Brown
[link](https://lwn.net/Articles/645810/)

在 Linux 中使用设备驱动程序的核心是了解 Linux 设备模型是（至少应该是）——而驱动程序构成了内核代码的一半以上。多年来，我一直在不同程度地参与各种设备驱动程序的工作，但直到最近，我才觉得自己真正理解了这种模式。这具有潜在的危险性，因为如果没有充分的了解，就很容易做出错误的选择。

这个问题，至少在我看来，根源在于术语。设备模型涉及 "device"、"driver"、"bus "和 "class "等术语。为了理解这个模型，我需要这些术语的准确定义，而有用的定义却很难找到。

LWN 2003 年的一篇[[Driver porting: Device model overview|文章]]就是一个很好的例子，因为它清楚地介绍了在其他文档和源代码中可以找到的一些定义。它将device定义为 "连接到总线（可能是虚拟的）上的物理或虚拟对象"。这听起来不错，也很笼统，但实际上与现实不符，甚至与十二年前撰写这篇文章时的现实也不符。

例如，在设备模型中，硬盘上的分区是一个 "device"，就像整个硬盘一样。硬盘作为一个整体可以连接到 "bus"上，但分区肯定不是：它充其量只能连接到整个硬盘。此外，有些设备什么都不连接，更不用说 "bus "了。列在 /sys/devices/virtual 目录下的设备并没有 "连接 "到任何设备。/sys/devices/virtual 目录并不是一条名为 "virtual"的特殊总线，它只是一个用来放置不属于其他地方的东西的地方。

在试图找到其他对象的定义时，也发现了类似的过度简化现象。这很可能是因为驱动程序模型仍在开发中，最终有用的含义尚未完全明确。十多年后的今天，现有的文档仍在提及相同的术语，并普遍使用相同的模糊定义。

### The eye of the beholder

让我对设备模型形成连贯理解的顿悟是，这些术语其实都没有任何外部含义。它们纯粹是由实现它们的代码定义的。device只是被嵌入到其他任意的数据结构，不多也不少。

这些术语的意义只来自于使用代码的开发人员的想法。多个独立的开发人员很可能会产生多种不同的含义。文档中与术语相关联的含义是早期开发人员的想法。随着时间的推移，这些想法会被修改，其他开发人员也会有其他想法。

任何带有""的东西""的定义可能是准确的，但对于考虑实施新驱动程序或修改旧驱动程序的人来说并无用处。同样，"其他开发人员在想什么 "的定义也过于模糊，没有实际意义。只要稍加努力，再加上精心挑选的几个例子，每一种说法都能得到一些充实，并共同构成一幅图景，希望这是一个良好的开端。因此，为了阐述我对设备模型的理解，特别是对这四个术语的理解，我将举出一些例子来说明其他开发人员的想法以及它们所提供的价值。

任何带有 struct device 的定义应该都是准确的，但对于考虑实施新驱动程序或修改旧驱动程序的人来说，这并不实用。同样，"其他开发人员在想什么 "也过于模糊，没有实际意义。只要稍加努力，再加上一些精心挑选的例子，就能使每一种想法都更加充实，从而形成一幅图景，希望这能成为一个良好的开端。因此，为了阐述我对设备模型的理解，特别是对这四个术语的理解，我将举出一些例子来说明其他开发人员的想法，以及 "strcut device "能提供什么价值。

第一个例子围绕德州仪器公司的[TCA6507](http://www.ti.com/product/tca6507)芯片展开。这是一个简单的硬件，它通过 "i2c "总线接受请求，并通过七个独立的引脚以不同的开/关模式消耗电流来做出响应。这特别是为了通过 LED 拉动电流使其发光，但同样也可以通过电阻器拉动电流以创建逻辑 0 或 1 电平。之所以选择这个例子，是因为它是我所熟悉的设备中最 "像设备 "的--它完全符合前面的定义。

第二个例子是 Linux 中的[工作队列](https://www.kernel.org/doc/Documentation/workqueue.txt)机制。它允许将任意任务交由异步完成，可以是立即完成，也可以是延迟后完成，并在此过程中尝试优化资源的使用。这也是我遇到的最不 "像设备 "的东西。

有了这些例子，再加上前面提到的块状设备，我们就可以继续讨论这些定义了。

### Devices

设备是一个实例。它对应于一个事物，或者最一般意义上的 "物体"。一件事物之所以成为一件事物，主要是因为一个人认为它是值得识别的东西。设备有时可以是一个特定的硬件，如集成电路，但也可以是此类电路的集合，或只是电路功能的一个组成部分。硬件根本不需要存在--设备可以是虚拟的，也可以代表根本没有实际物理等价物的东西。它只是一个 "东西"。

在 Linux 中，TCA6507 芯片由一个设备表示。七个可控引脚中的每个引脚都可以连接到某个设备，这样就可以产生更多的设备。例如，如果将一个引脚连接到 LED 上，那么就会有一个单独的设备来代表该 LED，当然也可以将其视为代表 "LED 加引脚 "组合的信号能力。不同的人可能会有不同的看法。

如果一个引脚连接了一个 "上拉 "电阻器，并用于发出逻辑电平信号，那么它在 Linux 中就表示为 "GPIO"--通用 I/O 引脚。就设备模型而言，所有配置为 GPIO 的引脚都表示为一个 "gpiochip "设备。因此，每个 LED 有一个设备，所有 GPIO 也有一个设备。

每个 GPIO 可在内部配置和使用，也可通过 sysfs 导出到用户空间。导出 GPIO 时，会创建一个新设备来代表该 GPIO。这可以看作是 /sys/class/gpio 中的一个目录，其中的文件可用于将输出电平设置为 1 或 0。

从这个例子中可以得到两个重要的启示。其一，选择取决于上下文，同样可能取决于开发人员。将 GPIO 组合到一个 "芯片 "中似乎是合理的，而将 LED 组合到一个 "芯片 "中似乎并不是优先事项，尽管有人认为这样做可能有价值。第二个教训是，在设备模型中把 "东西 "变成 "device "的一个原因是，它可以出现在 sysfs 中，并被直接检查或操作。

接着来看第二个例子，我们会发现一些不完全是 "设备类 "的东西。在 Linux 中，有许多 "东西 "或 "实例 "并不像设备，也不被表示为设备：文件系统和进程就是明显的例子。工作队列（work queue）就是其中的一个例子。

Linux 中的工作队列子系统会创建一个 "设备 "来代表每个不同的队列。这样做的[原因](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=226223ab3c4118ddd10688cc2c131135848371ab)很像（有时）为 GPIO 制作设备的原因--它允许通过 sysfs 来检查和管理事物（即工作队列）。一个东西不一定非得是设备才能出现在 sysfs 中；模块和文件系统就是明显的反例。不过，把某样东西变成 "设备"，是进入 sysfs 的一条相对容易且行之有效的途径。

使用 "设备 "来表示 "事物"，令人信服的理由似乎是接口。设备 "不仅拥有 sysfs 中的标准接口，还拥有电源管理的标准接口，并且可以使用只有设备才能使用的内部服务（如 devm 资源管理 API）。针对 "同类 "设备的不同定义，还有对 "同类 "设备进行分组的有用功能。

### Classes

" 类 "既是设备集合的实现，也是集合本身。" 类 "可以看作广泛意义上的 "驱动程序"。设备模型有被称为 "drivers "的特定对象，但 "类 "不是其中之一。

同一个类中的所有设备往往提供统一的接口给其他设备或用户空间（通过 sysfs 或其他方式）。不过，所包含的设备究竟有多统一，实际上取决于类。并不是一个类中的所有设备都有可选的接口，这种情况并不少见。同一类中的某些设备与其他设备完全不同的情况也很常见。

到目前为止，我们已经在示例中遇到了三个类。代表连接到 TCA6507 的 LED 的设备是 "leds "类的成员。该类支持物理 LED 的闪烁、闪光和亮度控制功能。该类需要一个可用的底层设备，如 TCA6507 或 GPIO 或其他几个选项之一。该底层设备必须能够打开或关闭 LED，可以设置亮度，甚至可以提供定时器功能，以给定的周期和占空比自动闪烁 LED。leds "类尽可能多地隐藏了这些细节，以提供一个简单的抽象设备。

与 "leds "类类似的还有 "gpio "类；它为各种能产生（输出）或感应（输入）电气逻辑电平的设备提供了统一的接口。如果底层设备能在电平变化时产生中断，"gpio "就能通过 poll() 将其转换为通知，或将其路由到其他设备的中断处理程序。gpio 类提供了 "gpiochip "设备和单个 "gpio "设备。

我们遇到的第三个类是 "磁盘 "类，它提供整个硬盘和硬盘中的分区。与 "leds "类一样，"disk "类提供了几种不同的存储功能接口，而 "disk "类则为这些功能提供了统一的接口。

实现 "gpios "和 "gpiochips "的 "gpio "类与实现 "disk "和 "partitions "的 "disk "类有一些明显的相似之处。这两者之间也有区别。其中之一就是 "gpio "和 "gpiochip "提供了完全不同的接口，而 "磁盘 "和 "分区 "在接口上有很多共同点--都有块大小并支持 I/O，但只有 "磁盘 "可以 "可移动"。

另一个不太明显的区别涉及设备模型的另一个方面。每个 "设备 "都可以有一个 "类型"。这种类型通常显示在相关 sysfs 目录下的 "uevent "文件中。例如，命令

    grep DEVTYPE /sys/class/block/*/uevent

将显示系统中每个块设备的类型。不过，设备模型并不知道 "gpio "类中的不同类型，因此 uevent 文件不会报告这些类型。人类或脚本需要从设备名称中推断出重要的类型。

这里列出的每个类都可以看作是为一系列不同硬件提供的通用接口。这似乎也是 "类 "设施的初衷之一。不过，"通用 "并不是一个非常精确的术语。一个开发人员认为是 "通用 "的，另一个开发人员可能认为是 "特定 "的。随着时间的推移，这些观点也会发生变化，特别是当一个简单或成功的界面被更广泛地使用，而不是其最初的语境时。

为了说明这一点，我们不妨简单了解一下 "背光 "类设备。图形显示器的背光可以使用多种不同的底层技术，包括 "发光二极管 "类设备。因此，从不同的角度看，LED 可能是一种通用的信号接口，也可能是一种特定的背光底层技术。这取决于谁的眼睛在看。

