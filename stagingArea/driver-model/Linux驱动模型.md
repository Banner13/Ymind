Patrick Mochel

# 摘要

新的驱动模型在Linux内核2.5版本设计和开发。最初的目的是为计算机中的每一个设备提供一种通用的表示方法和操作。这将允许现代电源管理例程在系统电源状态转换期间在整个设备空间上执行正确有序的暂停和恢复操作。

在初始模型的集成过程中，很明显，除了电源管理信息之外，还有许多与设备相关的概念可以推广和共享。新的驱动模型已经发展到提供几个对象的通用表示，包括：
- Devices
- Device drivers
- Bus drivers
- Device Classes
- Device Interfaces

驱动模型还为每个对象提供了一组对其进行操作的函数。这为整合和简化大量内核代码和数据结构提供了机会。

新的驱动模型已经被包含在主流内核中，从2.5.1版本开始，并且随着更多的驱动转换为利用其基础结构，它将继续成熟和发展。

本文档描述了新驱动模型的设计和实现。它涵盖了对象及其编程接口的描述，以及它们之间的概念和编程交互。它还包括kobject基础结构和sysfs文件系统的附录。这是作为驱动模型的结果而开发的两个重要特性，但是由于它们更通用的目的而从模型中分离出来。本文档将在如何在驱动程序模型中使用它们的上下文中介绍它们。

# 介绍

## 理论
通过分析PCI总线和USB总线驱动程序的行为，建立了驱动程序模型。这些总线在现代计算机系统中无处不在，并且代表了内核支持的大多数设备。它们包含对设备和驱动程序的动态添加、删除和电源管理的最成熟的支持。受PCI和USB子系统的启发，这些特性已经渗透到其他内核总线驱动程序中。它们被认为是适当的假设基础，说明如下。

这些假设适用于驱动程序模型所表示的大多数对象实例。少数对象被认为是例外，并且必须绕过驱动程序模型假设。

总线驱动程序是与某种类型的外围总线通信的一组代码。内核中总线驱动程序的一些示例包括：
- PCI
- USB
- SCSI
- IDE
- PCMCIA

总线驱动程序维护在该总线类型的所有实例上存在的设备列表，以及已注册的驱动程序列表。总线驱动程序是编译时选项，通常可以作为模块编译。同一总线类型的驱动程序永远不会同时存在多个实例。它的大部分（如果不是全部）内部数据结构都是静态分配的。

总线实例表示存在特定类型的总线，例如PCI bus 0。它们是在发现总线实例时动态分配的。它们包含设备列表，以及描述与设备连接的数据。总线实例目前没有在驱动程序模型中表示。但是，这里提到它们是为了注意它们与总线驱动程序对象之间的区别。

在启动期间，总线驱动程序发现其总线类型的实例。它扫描总线上当前的设备，并分配数据结构来描述每个设备。这些信息大部分是特定于总线的，比如设备的总线地址和设备标识信息。总线驱动器不需要知道设备执行的功能。该对象被插入到总线的设备列表中，总线驱动程序试图将其绑定到设备驱动程序。

设备类描述了设备执行的功能，而与特定设备所在的总线无关。设备类的例子如下：
- 音频输出设备
- 网络设备
- 磁盘
- 输入设备

设备类驱动程序维护属于该类的设备和驱动程序的列表。它们是可选的代码体，可以作为模块编译。它的数据结构是静态分配的。设备类定义对象类型来描述注册到它的设备。这些对象仅在类的上下文中定义设备，因为类独立于设备的总线类型。

设备类的特征是一组接口，这些接口允许用户进程与其类型的设备进行通信。接口定义了用于与这些设备通信的协议，该协议在用户空间设备节点中具有特征。一个类可以包含多个用于与设备通信的接口，尽管该类的设备和驱动程序可能不支持该类的所有接口。

设备驱动程序是一个代码体，它为特定总线类型上的一组设备实现设备类的一个或多个接口。它们包含一些静态分配的结构来描述驱动到它的总线和类，并维护绑定设备的列表。

在启动期间，一个驱动程序向它的总线注册，总线将这个驱动程序插入到它的内部驱动程序列表中。然后总线尝试将驱动程序绑定到总线的设备列表。总线将它支持的特定于总线的设备ID号列表与总线上设备的ID号进行比较。如果匹配成功，设备将被“附加”到驱动程序上。驱动程序分配一个特定于驱动程序的对象来描述设备。这通常还包括一个特定于类的对象，驱动程序使用它将设备注册到它的类中。

## 基本结构
驱动模型提供了一组对象来表示上面描述的实体。以前，这些对象（尤其是设备）的内核表示根据它们提供的功能和设计它们的总线类型有很大的不同。这些信息中的大部分是特定于对象类型的，尽管有些信息可以进行通用编码，这些编码构成了驱动程序模型对象。

驱动模型对象的大多数成员都包含描述对象的元数据，以及表示组和从属对象列表中的成员关系的链接信息。驱动模型对象定义可以在头文件include/linux/ device.h中找到。

驱动模型还提供了一组对每个对象进行操作的函数。这些函数在本文档中被称为“驱动模型核心”。它们在内核源代码树的drivers/base/中实现。每组操作都是特定于对象的，并在各自的部分中使用对象进行了详细描述。但是，对象之间存在一些共性，这些共性反映在核心的功能中。这里描述这些是为了提供模型的透视图，并避免在每个部分中重复这些目的。

每个驱动模型对象都支持动态添加和删除。每个对象都有特定于该对象的register（）和unregister（）函数。注册初始化对象，将其插入类似对象的列表中，并在sysfs文件系统中为该对象创建一个目录。当发现设备或插入包含设备、总线或类驱动程序的模块时，就会发生注册。当驱动模块被卸载或设备被物理移除时，会发生注销。取消注册将删除对象的sysfs目录，并将其从类似对象的列表中删除。

为了支持动态删除，每个对象都包含一个引用计数，可以通过对象特定的get（）和put（）函数进行调整。在函数中使用对象之前，应该调用对象的get（）例程。Get（）返回对对象的引用。put（）例程应该在使用对象完成函数之后调用。它没有返回值。

当且仅当对象的引用计数达到0时，可以释放该对象，或者卸载其模块。当对象的unregister（）函数返回时，另一个进程可能仍然持有对该对象的引用。盲目地释放对象的内存可能导致其他进程访问无效或重新分配的内存。

驱动程序模型用来防止这些错误的方法在各个对象的部分中进行了描述。驱动模型对象之间的相似性，以及在这些对象上执行类似操作所需的大量复制代码，促使人们努力创建一种通用对象类型，不仅可以在驱动模型对象之间共享，还可以在所有支持动态注册和引用计数的复杂内核对象之间共享。

kobject一般描述一个对象。它可以嵌入到更大的数据类型中，以提供通用对象元数据和引用计数机制。子系统表示一组对象。kobject可以动态地在子系统中注册和取消注册。当一个kobject被注册时，它被初始化并插入到它的子系统的对象列表中。还将在sysfs中创建一个目录，如下所述。取消注册将删除kobject的sysfs目录，并将其从子系统列表中删除。Kobjects也有引用计数和get（）和put（）操作来调整它。一个kobject只能属于一个子系统，而一个子系统必须只包含相同嵌入的kobject。

kobject的功能与驱动程序模型核心非常相似。驱动程序模型函数已经被调整为使用kobject基础结构，并且有些函数除了调用相关的kobject函数之外没有提供更多的功能。

kobject和子系统基础结构见附录A。

sysfs文件系统最初是作为一种将驱动模型对象及其属性导出到用户空间的方法而创建的。它已经与kobject基础结构集成，因此它可以直接与泛型对象通信，从而允许它对表示的对象进行引用计数。

根据kobject的祖先，所有注册的kobject都会在sysfs中接收一个位于特定位置的目录。这在文件系统中为用户空间提供了一个有意义的对象层次结构，可以使用基本的文件系统工具，如ls(l)、find(l)和grep(l)来进行导航。

对象的属性可以通过sysfs导出，并在文件系统中表示为文本文件。Sysfs为用户进程提供了一种读写属性的方法。属性的内核导出器可以定义sysfs在对属性文件执行读或写操作时调用的方法。

在附录B中讨论了sysfs文件系统及其编程接口。

## 总结
新的驱动模型实现了大量用于描述和操作设备相关对象的基础设施。这种基础设施能够消除冗余的内核代码和数据结构，特别是在对象引用计数和列表成员管理方面。这降低了设备、总线和类驱动程序的复杂性，使它们更容易编写和阅读。数据结构的整合也使得实现对传统上不同对象的对象进行操作的通用功能变得更加容易。

虽然这个文档描述了驱动模型的基本对象和操作，但是它忽略了很多东西。它没有描述如何利用它来进行电源管理或实现动态和可扩展的设备命名方案。这些主题超出了本文档的范围，留待其他讨论。

同样，本文档只对kobject基础结构和sysfs文件系统进行了肤浅的描述。包括这些内容只是为了提供足够的上下文来完成对驱动程序模型的讨论，最好在其他文档中介绍。

# kobjects 和 Subsystem

开发kobject基础结构是为了巩固驱动模型对象的通用方面。其结果是一个简单的对象类型，旨在为更复杂的对象类型提供基础。结构体Subsystem用于描述和管理对象集。创建它也是为了巩固和统一驱动模型对象和功能。

## kobject
结构体 kobject在结构中提供基本对象属性，该结构被设计为嵌入到更大的结构中。嵌入kobject的Subsystem可以使用它的成员，以及它们的助手，而不是定义它们自己的成员。
当注册一个kobject时，它应该初始化以下字段：
- name
- parent
- subsystem

![[stagingArea/driver-model/Pasted image 20241022102050.png]]

‘name’给出了对象的标识，并为创建的sysfs目录提供了一个名称。‘parent’为对象提供祖先上下文。kobject基础结构将kobject插入到位于其子系统中的有序列表中。顺序依赖于kobject的父对象——对象直接插入到它的父对象之前。这种排序保证了向前迭代时的深度优先排序，向后迭代时的宽度优先排序。

‘subsys’通知kobject的控制子系统的kobject核心。一个对象一次只能属于一个子系统。注意，如果kobject的父指针没有被kobject核心设置，则kobject的父指针被设置为指向它的子系统。

## kobject编程接口

![[stagingArea/driver-model/企业微信截图_17295644243484.png]]
对象可以动态地从它们的子系统中添加和删除。kobject编程接口提供了两个并行编程模型，就像设备一样。kobject_register（）初始化kobject，并添加到kobject层次结构中。同样的操作也可以通过手动调用kobject_init（）和kobject_add（）来执行。

kobject_unregister（）从系统中删除kobject并减少其引用计数。当kobject的引用计数达到0时，将调用kobject_cleanup（）来拆除kobject。或者，可以调用kobject_del（）和kobject_put（）来获得相同的结果。kobject_cleanup（）只能由kobject_put（）调用，不应该手动调用。

并行接口的提供为kobject模型的用户提供了更大的灵活性。kobject_add（）将kobject插入它的子系统，并为它创建一个sysfs目录。用户可能不希望这种情况立即发生，或者根本不希望发生。可以调用kobject_init（）将kobject初始化为一个可用引用计数的状态。稍后，用户可以调用kobject_add（）将设备添加到子系统并创建其sysfs目录。

使用基础初始化和Add调用的用户应该也使用低级kobject_del（）和kobject_put（）调用，即使它们如kobject_unregister（）等效。尽管 kobject_register() 和 kobject_unregister() 目前不做额外的工作，但也不排除它们会做额外的工作。遵守对称性也会使代码更容易遵循和理解。

kobject包含一个引用计数，在访问它之前应该使用kobject_get（）进行递增，在不再使用它之后使用kobject_put（）进行递减。在对象上保持正引用计数可以保证结构在使用时不会被删除和释放。

## Subsystems

![[stagingArea/driver-model/企业微信截图_17295773414966.png]]
定义了结构体Subsystem来描述 kobjects集合。“Subsystem”对于这样一个通用对象来说是一个模棱两可的名字；“container”更准确，以后可能会有所变化。一个Subsystem对象包含管理其从属kobject的一组集合。用户可以将Subsystem对象结构嵌入到更复杂的对象中，并使用其中包含的字段，而不是定义自己的字段。

结构体Subsystem包含一个kobject，用于包含关于Subsystem本身的泛型对象元数据。这也是为了表示Subsystem在另一个Subsystem中的成员关系。

Subsystem对象包含一个列表，注册对象被插入其中。‘rwsem’是一个保护对列表访问的信号量。它应该总是在遍历列表或添加或删除成员之前进行。

Subsystem被认为是分层的，因为一些Subsystem包含下级Subsystem或对象容器。‘parent’字段可以用来表示Subsystem的父节点。

‘sysfs_ops’是一个指向一组操作的指针，Subsystem必须定义这些操作来读取和写入通过sysfs文件系统为从属kobject导出的属性。‘default_attrs’是一个以null结尾的属性数组，为每个注册到子系统的kobject无条件导出。

我们将在下一节中讨论Sysfs，这些字段将被涵盖。

‘release’方法被定义为Subsystem拆除注册到它的对象的一种方法。Subsystem应该实现这个方法。当一个kobject的引用计数达到0时，将调用kobject_cleanup（）来拆除该设备。这个引用是kobject的Subsystem和它的“release”方法，它调用这个方法来允许Subsystem拆除设备（因为子系统可能将kobject嵌入到更大的东西中，它必须转换到它）。

## 编程接口

![[stagingArea/driver-model/企业微信截图_17295776352477.png]]

子系统提供了与kobjects类似的编程模型。然而，它们只允许简单的register（）和unregister（）语义，并且不导出中间调用供内核的其余部分使用。同样的，子系统的引用计数可以使用subsys_get（）递增，使用subsys_put（）递减。

