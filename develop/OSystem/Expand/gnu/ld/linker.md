
[原文地址](https://users.informatik.haw-hamburg.de/~krabat/FH-Labor/gnupro/5_GNUPro_Utilities/c_Using_LD/ldOverview_of_ld_the_GNU_linker.html)

	目录
	
	1 概述
		ld 合并多个目标并整理文件，重定位它们的数据并绑定符号引用。编译程序的最后一步通常是运行ld。
		ld接受用AT&T的链接编辑器命令语言语法的超集编写的链接器命令语言文件，以提供对链接过程的显式和全面的控制。该版本的ld使用通用的BFD库对目标文件进行操作。这允许ld以许多不同的格式读取、合并和写入目标文件—例如，COFF或a.out。不同的格式可以链接在一起以产生任何可用类型的目标文件。请参见第5章[BFD]，第93页，了解更多信息。
		除了灵活性之外，gnu链接器在提供诊断信息方面比其他链接器更有帮助。许多链接器在遇到错误时立即放弃执行;只要有可能，ld就会继续执行，从而允许您识别其他错误(或者，在某些情况下，即使出现了错误，也可以获得输出文件)。
		
	2 调用
		gnu链接器ld旨在涵盖广泛的情况，并尽可能与其他链接器兼容。因此，您有许多选择来控制它的行为。
		
		2.1命令行选项
			链接器支持大量的命令行选项，但在实际操作中，很少在特定上下文中使用它们。例如，ld的一个常见用法是在一个标准的、受支持的 Unix 系统上链接标准的 Unix 对象文件。On such a system, to link a file
				hello.o:
					ld -o output /lib/crt0.o hello.o -lc
			这告诉ld生成一个名为output的文件，作为链接文件/lib/crt0 和 hello.o 以及来自标准搜索目录下 libc.a 的结果。(请参阅下面对' -l '选项的讨论。)
			ld的某些命令行选项可以在命令行中的任何位置指定。然而，提及文件的选项，如'-l'或'-T'，会导致在命令行中出现该选项的位置读取文件，相对于对象文件和其他文件选项而言。用不同的参数重复非文件选项，要么没有进一步的效果，要么覆盖之前出现的选项（那些在命令行左边的）。在下面的描述中指出了那些可以有意义地指定一次以上的选项。
			非选项参数是要被连接在一起的目标文件或档案。它们可以跟在命令行选项后面、前面，或者与命令行选项混合在一起，但对象文件参数不能放在选项和其参数之间。
			通常链接器被调用时至少有一个对象文件，但你可以使用'-l'、'-R'和脚本命令语言指定其他形式的二进制输入文件。如果没有指定二进制输入文件，链接器不会产生任何输出，并发出 "没有输入文件 "的信息。
			如果链接器不能识别一个对象文件的格式，它将假定它是一个链接器脚本。以这种方式指定的脚本会扩展用于链接的主要链接器脚本（无论是默认的链接器脚本还是通过使用'-T'指定的脚本）。该特性允许链接器链接到一个文件，该文件看起来像是一个目标文件或存档，但实际上只是定义了一些符号值，或使用INPUT或GROUP加载其他对象。以这种方式指定一个脚本仅仅是增加了主链接器脚本，将额外的命令放在主脚本之后;使用“-T”选项完全替换默认链接器脚本，但请注意INSERT命令的效果。参见第3章[脚本]，第37页。
			对于名称为单个字母的选项，选项参数必须跟在选项字母后面且，不能有空格，或者作为单独的参数紧跟在需要这些参数的选项后面。
			对于多个字母组成的选项，可以在选项名称前加一个或两个破折号;例如，' -trace-symbol '和'--trace-symbol '是等效的。注意——这条规则有一个例外。以小写“o”开头的多个字母选项只能在之前加两个破折号。这是为了减少与“-o”选项的混淆。例如' -o magic '设置输出文件名为' magic '，而'--magic '设置输出的NMAGIC标志。
			多字母选项的参数必须用等号与选项名称分开，或者作为单独的参数直接在需要它们的选项之后给出。例如，'--trace-symbol foo '和'--trace-symbol=foo '是等效的。接受多字母选项名称的唯一缩写。
			注意-如果链接器是通过编译器驱动间接调用的(例如' gcc ')，那么所有链接器命令行选项都应该加上' -Wl '前缀(或任何适合特定编译器驱动的选项)，像这样:
				gcc -Wl,--start-group foo.o bar.o -Wl,--end-group
			这是很重要的，因为否则编译器驱动程序可能会静默地删除链接选项，从而导致错误的链接。当通过驱动程序传递需要值的选项时，也会产生混淆，因为在选项和参数之间使用空格作为分隔符，导致驱动程序只将选项传递给链接器，而将参数传递给编译器。在这种情况下，使用单字母和多字母选项的连接形式是最简单的，例如:
				gcc foo.o bar.o -Wl,-eENTRY -Wl,-Map=a.map
		下面是GNU链接器所接受的通用命令行的列表：
		@file
				从文件读取命令行选项。读取的选项被插入到原始的@file选项的位置。
				如果file不存在，或者无法读取，那么将按字面意思处理该选项，而不会删除该选项。
				文件中的选项由空格分隔。通过将整个选项括在单引号或双引号中，可以在选项中包含空白字符。
				任何字符(包括反斜杠)都可以通过在要包含的字符前加上反斜杠来包含。
				文件本身可能包含额外的@file选项;任何这样的选项都将被递归处理。
		-a keyword
				为了兼容HP/UX，支持此选项。关键字参数必须是字符串' archive '， ' shared '或' default '中的一个。
				' -aarchive '在功能上等价于' -Bstatic '，另外两个关键字在功能上等价于' -Bdynamic '。此选项可多次使用。
		-A architecture
		--architecture=architecture
				在ld的当前版本中，这个选项只对Intel 960系列架构有用。
				在ld配置中，体系结构参数标识960系列中的特定体系结构，启用一些保护措施并修改存档库搜索路径。
				参见第4.2节[ld和Intel 960家族]，第75页，详细信息。
				未来的ld版本可能会为其他体系结构家族支持类似的功能。
		-b input-format
		--format=input-format
				Ld可以配置为支持多种目标文件。
				如果你的ld是这样配置的，你可以使用' -b '选项来指定命令行中跟随该选项的输入目标文件的二进制格式。
				即使ld被配置为支持其他对象格式，你通常也不需要指定，
				因为ld应该被配置为期望将每台机器上最常用的格式作为默认输入格式。
				input-format为文本字符串，是BFD库支持的特定格式的名称。
				(你可以使用' objdump -i '列出可用的二进制格式。)参见第5章[BFD]，第93页。
				
				如果您链接的文件是不常见的二进制格式，您可能需要使用此选项。
				你也可以使用' -b '来显式地切换格式(当链接不同格式的目标文件时)，
				通过在特定格式的每组目标文件之前包含' -b input-format '。
				
				默认格式取自环境变量GNUTARGET。
				参见第2.2节[环境]，第35页。您还可以使用TARGET;参见第41页3.4.3节[格式命令]。
		-c MRI-commandfile
		--mri-script=MRI-commandfile
				为了与MRI产生的链接器兼容，ld接受用一种替代的受限命令语言编写的脚本文件，见附录A [MRI兼容脚本文件]，第101页。
				引入带有选项' -c '的MRI脚本文件;使用' -T '选项来运行用通用的ld脚本语言编写的链接器脚本。
				如果MRI-cmdfile不存在，ld将在任何' -L '选项指定的目录中查找它。
		-d
		-dc
		-dp
				这三个选项是等价的；为了与其他链接器兼容，支持多种形式。
				即使指定了一个可重定位的输出文件（用'-r'），它们也会给公共符号分配空间。
				脚本命令FORCE_COMMON_ALLOCATION也有同样的效果。参见第3.4.5节 [其他命令]，第44页。
		-e entry
		--entry=entry
				使用entry作为程序开始执行的显式符号，而不是默认的入口点。
				如果没有名为entry的符号，链接器将尝试将entry解析为一个数字，
				并使用该数字作为条目地址(该数字将被解释为10进制;你可以使用前导' 0x '表示16进制，或前导' 0 '表示8进制)。
				参靠第39页的3.4.1节[Entry Point]，讨论默认值和指定入口点的其他方法。
		--exclude-libs lib,lib,...
				指定一个不应自动导出符号的存档库列表。
				库名可以用逗号或冒号分隔。
				指定——exclude-libs ALL将从自动导出中排除所有存档库中的符号。
				此选项仅适用于连接器的i386 PE目标端口和ELF目标端口。
				对于i386 PE，不管这个选项是什么，在.def文件中显式列出的符号仍然会被导出。
				对于ELF目标端口，受此选项影响的符号将被视为隐藏的。
		--exclude-modules-for-implib module,module,...
				指定目标文件或存档成员的列表，不应自动导出其中的符号，但应将其全部复制到链接期间生成的导入库中。
				模块名可以用逗号或冒号分隔，并且必须与ld打开文件时使用的文件名完全匹配;
				对于存档成员，这只是成员名称，但是对于目标文件，
				列出的名称必须包含并精确匹配链接器命令行中用于指定输入文件的任何路径。
				此选项仅对链接器的i386 PE目标端口可用。无论此选项如何，在.def文件中显式列出的符号仍然会被导出。
		-E
		--export-dynamic
		--no-export-dynamic
				当创建一个动态链接的可执行文件时，
				使用' -E '选项或'——export-dynamic '选项会导致链接器将所有符号添加到动态符号表中。
				动态符号表是动态对象在运行时可见的一组符号。
				
				如果你不使用这两个选项中的任何一个(或者使用'——no-export-dynamic '选项来恢复默认行为)，
				动态符号表通常只包含那些链接中提到的动态对象引用的符号。
				
				如果使用dlopen加载需要引用程序定义的符号的动态对象，而不是其他动态对象，
				那么在链接程序本身时可能需要使用这个选项。
				
				如果输出格式支持，还可以使用动态列表来控制应该将哪些符号添加到动态符号表中。
				参见'——dynamic-list '的描述。

				注意，此选项特定于ELF目标端口。PE目标支持类似的功能，从DLL或EXE导出所有符号;
				请参阅下面对'——export-all-symbols '的描述。
		-EB
				链接大端目标文件。这会影响默认的输出格式。
		-EL
				链接小端目标文件。这会影响默认的输出格式。
		-f name
		--auxiliary=name
				创建ELF共享对象时，将内部DT AUXILIARY字段设置为指定的名称。
				这告诉动态连接器，共享对象的符号表应该被用作共享对象名称的符号表的辅助过滤器。
				
				如果您稍后将一个程序链接到这个筛选器对象，那么，当您运行该程序时，动态连接器将看到DT AUXILIARY字段。
				如果动态连接器解析来自过滤器对象的任何符号，它将首先检查共享对象名称中是否有定义。
				如果有，将使用它来代替过滤器对象中的定义。共享对象名称不需要存在。
				因此，共享对象名可能用于提供某些函数的替代实现，可能用于调试或用于特定于机器的性能。
				此选项可以指定多次。DT AUXILIARY条目将按照它们在命令行中出现的顺序创建。
		-F name
		--filter=name
				创建ELF共享对象时，将内部DT FILTER字段设置为指定的名称。
				这告诉动态连接器，正在创建的共享对象的符号表应该用作共享对象名的符号表的过滤器。
				
				如果您稍后将一个程序链接到这个过滤器对象，
				那么，当您运行该程序时，动态连接器将看到DT filter字段。
				动态链接器通常会根据过滤器对象的符号表来解析符号，但它实际上会链接到共享对象名称中的定义。

				因此，可以使用筛选器对象来选择对象名称提供的符号的子集。

				一些较老的链接器在整个编译工具链中使用' -F '选项来为输入和输出对象文件指定对象文件格式。
				gnu链接器使用其他机制来实现这个目的:' -b '， '——format '， '——oformat '选项，
				链接器脚本中的TARGET命令，以及GNUTARGET环境变量。
				当不创建ELF共享对象时，gnu链接器会忽略' -F '选项。
		-fini=name
				在创建ELF可执行或共享对象时，通过将DT FINI设置为函数的地址，
				在可执行或共享对象卸载时调用NAME。
				默认情况下，链接器使用_fini作为要调用的函数。
		- g
				忽略。提供与其他工具的兼容性。
		-G value
		--gpsize=value
				使用GP寄存器设置要优化的对象的最大大小。
				这只对对象文件格式有意义，如MIPS ECOFF，它支持将大对象和小对象放在不同的部分。
				对于其他对象文件格式，这将被忽略。
		-h name
		-soname=name
				在创建ELF共享对象时，将内部DT SONAME字段设置为指定的名称。
				当一个可执行文件链接到一个有DT SONAME字段的共享对象时，那么当该可执行文件运行时，
				动态链接器将尝试加载由DT SONAME字段指定的共享对象，而不是使用提供给链接器的文件名。
		-i
				执行增量链接(与选项' -r '相同)。
		-init=name
				当创建ELF可执行或共享对象时，通过将DT INIT设置为函数的地址，
				在可执行或共享对象加载时调用NAME。默认情况下，链接器使用_init作为要调用的函数。
		-l namespec
		--library=namespec
				将namespec指定的存档文件或目标文件添加到要链接的文件列表中。
				此选项可多次使用。如果namespec的形式是':filename '，
				ld将在库路径中搜索名为filename的文件，否则它将在库路径中搜索名为' libnamespec.a '的文件。
				在支持共享库的系统上，ld也可以搜索' libnamespa '以外的文件。
				特别地，在ELF和SunOS系统上，ld会在搜索‘ libnamespec.a ’之前搜索 libnamespec.so ’。(按照惯例，.so扩展表示共享库。)
				请注意，此行为不适用于':filename '，它总是指定一个名为filename的文件。
				
				链接器只会在命令行中指定的位置搜索存档一次。
				如果存档在命令行中存档之前的某个对象中定义了一个未定义的符号，链接器将从存档中包含相应的文件。
				但是，稍后在命令行上出现的对象中未定义的符号不会导致链接器再次搜索存档。
				
				请参阅“-(”选项，以了解强制链接器多次搜索存档的方法。
				
				您可以在命令行中多次列出相同的存档。

				这种类型的归档搜索是Unix链接器的标准。但是，如果您在AIX上使用ld，请注意它与AIX连接器的行为是不同的。
		-L searchdir
		--library-path=searchdir
				将path searchdir添加到ld将搜索存档库和ld控制脚本的路径列表中。
				您可以多次使用此选项。
				按照在命令行中指定的顺序搜索目录。在默认目录之前搜索命令行中指定的目录。
				所有' -L '选项适用于所有' -L '选项，无论选项出现的顺序。
				' -L '选项不影响ld搜索链接器脚本的方式，除非指定了' -T '选项。
				
				如果searchdir以=开头，那么=将被sysroot前缀替换，这是在配置链接器时指定的路径。
				
				搜索的默认路径集(不使用' -L '指定)取决于ld使用的模拟模式，在某些情况下还取决于它的配置方式。
				参考第2.2节[Enviroment]，第35页。
				
				路径也可以用SEARCH_DIR命令在链接脚本中指定。

				通过这种方式指定的目录将在命令行中出现链接器脚本的地方进行搜索。
		-m emulation
				模拟仿真链接器。您可以使用'——verbose '或' -V '选项列出可用的模拟。
				
				如果未使用' -m '选项，则从lsimulation环境变量中获取模拟(如果该环境变量已定义)。
				
				否则，默认模拟取决于如何配置链接器。
		-M
		--print-map
				将链接映射打印到标准输出。link map提供了该链路的相关信息，包括:
					•对象文件映射到内存的地方。
					•如何分配常用符号。
					•链接中包含的所有存档成员，并提及导致该存档成员被引入的符号。
					•赋值给符号。
					注意:如果符号的值是由一个表达式计算的，该表达式涉及到同一个符号的前一个值的引用，
					那么在链接映射中可能不会显示正确的结果。
					这是因为链接器丢弃中间结果，只保留表达式的最终值。
					在这种情况下，链接器将显示由方括号括起来的最终值。
					例如，一个链接器脚本包含:
						foo = 1
						foo = foo * 4
						foo = foo + 8
					如果使用了' -M '选项，将在链接映射中产生以下输出:
						0x00000001 foo = 0x1
						[0x0000000c] foo = (foo * 0x4)
						[0x0000000c] foo = (foo + 0x8)
					有关链接器脚本中表达式的更多信息，请参阅第66页的3.10节[Expressions]。
		-n
		--nmagic Turn off
				关闭部分的页面对齐，如果可能的话将输出标记为nmagic。
		-N
		--omagic
				将文本和数据部分设置为可读和可写。
				另外，不要对数据段进行分页对齐，并禁用对共享库的链接。
				如果输出格式支持Unix风格的魔术数字，那么将输出标记为OMAGIC。

				注意:尽管PE-COFF目标允许可写文本部分，但它不符合微软发布的格式规范。
		--no-omagic
				这个选项抵消了' -N '选项的大部分效果。
				它将文本部分设置为只读，并强制数据段与页面对齐。注意-这个选项不支持对共享库的链接。使用' -Bdynamic '。
		-o output
		--output=output
				使用output作为ld生成的程序的名称;
				如果未指定此选项，则名称' a。默认使用Out '。脚本命令OUTPUT还可以指定输出文件名。
		-O level
				如果level是一个大于0的数值，ld将优化输出。这可能需要更长的时间，因此可能应该只对最终的二进制文件启用。
				目前，这个选项只影响ELF共享库的生成。连接器的未来版本可能会更多地使用这个选项。
				同样，目前对于这个选项的不同非零值，链接器的行为没有区别。同样，这可能会在未来的版本中改变。
		-q
		--emit-relocs
				将重定位部分和内容放在完全链接的可执行文件中。
				Post链接分析和优化工具可能需要这些信息，以便对可执行文件进行正确的修改。这会导致更大的可执行文件。
				
				该选项目前仅在ELF平台上支持。
		--force-dynamic
				强制输出文件具有动态段。这个选项是特定于VxWorks目标的。
		-r
		--relocatable
				产生重定位输出-例如，生成一个输出文件，该文件可以作为ld的输入。这通常被称为部分链接。
				作为一个副作用，在支持标准Unix魔鬼数字的环境中，该选项还将输出文件的魔鬼数字设置为OMAGIC。
				// 译注(魔鬼数字指未定义，未解释的数值)
				如果不指定此选项，则生成绝对文件。链接c++程序时，此选项不会解析对构造函数的引用;要做到这一点，使用“-Ur”。
				
				当输入文件的格式与输出文件不相同时，只有当输入文件不包含任何重定位时，才支持部分链接。
				不同的输出格式可以有进一步的限制;例如，一些基于a.out的格式根本不支持与其他格式的输入文件的部分链接。
				这个选项的作用与' -i '相同。
		-R filename
		--just-symbols=filename
				从文件名读取符号名称及其地址，但不定位它或在输出中包含它。
				这允许您的输出文件以符号的方式引用在其他程序中定义的内存的绝对位置。
				您可以多次使用此选项。
				
				为了与其他ELF链接器兼容，如果' -R '选项后面跟着一个目录名，而不是一个文件名，它将被视为' -rpath '选项。
		-s
		--strip-all
				从输出文件中省略所有符号信息。
		-S
		--strip-debug
				从输出文件中省略调试器符号信息(但不是所有符号)。
		-t
		--trace
				当ld处理输入文件时，打印它们的名称。
		-T scriptfile
		--script=scriptfile
				使用scriptfile作为链接器脚本。
				这个脚本替换了ld的默认链接器脚本(而不是添加到它)，因此commandfile必须指定描述输出文件所需的所有内容。
				参见第3章[脚本]，第37页
				。如果scriptfile在当前目录中不存在，ld将在前面的' -L '选项指定的目录中查找它。多个“-T”选项叠加。
		-dT scriptfile
		--default-script=scriptfile
				使用scriptfile作为默认链接器脚本。参见第3章[脚本]，第37页。
				
				该选项类似于“——script”选项，不同之处在于脚本的处理被延迟到命令行的其余部分被处理之后。
				这允许将选项放在命令行上的'——default-script '选项之后，以影响链接器脚本的行为，
				当链接器命令行不能由用户直接控制时，这是很重要的。(例如，因为命令行是由另一个工具，如' gcc '构建)。
		-u symbol
		--undefined=symbol
				强制 symbol 作为未定义的符号输入到输出文件中。
				例如，这样做可能会触发从标准库中链接其他模块。
				' -u '可以用不同的选项参数重复，以输入其他未定义的符号。这个选项等价于EXTERN链接器脚本命令。
		-Ur
				对于除c++程序之外的任何程序，这个选项等价于' -r ':它生成可重定位的输出——例如，输出文件可以作为ld的输入。
				在链接c++程序时，' -Ur '将引用解析为构造函数，这与' -r '不同。
				它不工作使用' -Ur '对文件本身链接的' -Ur ';一旦构建了构造函数表，就不能被添加。
				
				只在最后一个部分链接中使用“-Ur”，其他部分使用“-r”。
		--unique[=SECTION]
				为每个匹配SECTION的输入部分创建一个单独的输出部分，
				或者如果缺少可选的通配符SECTION参数，则为每个未指定输入部分创建一个单独的输出部分。
				未指定部分是指在链接器脚本中没有特别提到的部分。
				你可以在命令行中多次使用这个选项；
				它可以防止具有相同名称的输入部分的正常合并，从而推翻链接器脚本中的输出部分分配。
		-v
		--version
		-V
				显示ld的版本号。' -V '选项还列出支持的模拟。
		-x
		--discard-all
				删除所有本地符号。
		-X
		--discard-locals
				删除所有临时本地符号。
				(这些符号以系统特定的本地标签前缀开始，通常为'。“L”表示ELF系统，“L”表示传统的a.out系统。)
		-y symbol
		--trace-symbol=symbol
				打印出现 symbol 的每个链接文件的名称。
				你可以在命令行中多次使用这个选项；
				在许多系统中，必须在前面加上下划线。
				
				当你的链接中有一个未定义的符号，但不知道引用来自哪里时，这个选项很有用。
		-Y path
				将path添加到默认库搜索路径。这个选项的存在是为了与Solaris兼容。
		-z keyword
				有效的 keyword 有:
				‘combreloc’
					结合多个重定位部分，并对其进行排序，使动态符号查找缓存成为可能。
				‘defs’
					禁止在目标文件中使用未定义的符号。在共享库中仍然允许未定义的符号。
				‘execstack’
					将对象标记为需要可执行堆栈。
				‘initfirst’
					此选项仅在构建共享对象时有意义。
					它标记该对象，以便其运行时初始化将在同时引入该进程的任何其他对象的运行时初始化之前发生。
					类似地，对象的运行时结束将发生在任何其他对象的运行时结束之后。
				‘interpose’
					标记其符号表放在除了主要可执行文件之外的所有符号之前的对象。
				‘lazy’
					当生成可执行库或共享库时，
					标记它，告诉动态连接器将函数调用解析推迟到函数被调用时(惰性绑定)，而不是在加载时。
					惰性绑定是默认值。
				‘loadfltr’
					标记在运行时立即处理其筛选器的对象。
				‘muldefs’
					允许多个定义。
				‘nocombreloc’
					禁用多个重定位段组合。
				‘nocopyreloc’
					复制重定位无效。
				‘nodefaultlib’
					标记此目标的依赖项搜索将忽略任何默认库搜索路径的目标文件。
				‘nodelete’
					标志着该目标在运行时不应该被卸载。
				‘nodlopen’
					标志着dloopen不可用。
				‘nodump’
					标志着该目标不能通过dldump转储。
				‘noexecstack’
					该目标不需要可执行堆栈。
				‘norelro’
					不要在目标中创建ELF PT_GNU_RELRO段头。
				‘now’
					当生成可执行程序或共享库时，
					标记它，告诉动态连接器在程序启动时解析所有符号，
					或者在共享库使用dlopen链接到时解析所有符号，而不是将函数调用解析推迟到函数第一次被调用时。
				‘origin’
					目标文件可能包含$ORIGIN。
				‘relro’
					在对象中创建一个ELF PT_GNU_RELRO段头。
				‘max-page-size=value’
					将模拟最大页面大小设置为value。
				‘common-page-size=value’
					将模拟通用页面大小设置为value。
				Solaris兼容性忽略了其他关键字。
		-( archives -)
		--start-group archives --end-group
				 archives 应该是存档文件的列表。它们可以是显式的文件名，也可以是“-l”选项。
				 
				 重复搜索指定的存档，直到没有新的未定义的引用被创建。
				 通常，归档文件只按照在命令行上指定的顺序搜索一次。
				 如果需要该存档中的某个符号来解析存档中的对象引用的未定义符号(该符号稍后会出现在命令行中)，
				 则链接器将无法解析该引用。
				 
				 通过对存档进行分组，将对它们进行重复搜索，直到解析所有可能的引用。
				 
				 使用这个选项有很大的性能成本。最好只在两个或多个存档之间存在不可避免的循环引用时使用它。
		--accept-unknown-input-arch
		--no-accept-unknown-input-arch
				 告诉链接器接受架构无法识别的输入文件。

				假设用户知道他们在做什么，并有意链接到这些未知的输入文件中。
				在2.14版本之前，这是链接器的默认行为。
				从2.14版本开始的默认行为是拒绝这样的输入文件，因此添加了“——accept-unknown-input-arch”选项来恢复旧的行为。
		--as-needed
		--no-as-needed
				
				这个选项影响在命令行中提到的动态库的ELF DT NEEDED标签，在"--as-needed "选项之后。
				通常情况下，链接器会为命令行中提到的每个动态库添加一个DT NEEDED标签，不管这个库是否真的需要。
				'--as needed'会使DT NEED标签只对满足常规对象的符号引用的库发出，而该库在被链接时是未定义的，
				或者，如果该库在链接到该点的其他库的DT NEED列表中没有找到，则是另一个动态库的引用。
				'--no-as-need'恢复了默认行为。
		--add-needed
		--no-add-needed
				该选项影响动态库中ELF DT NEEDED标记对动态库的处理，该标记在命令行“——no-add-needed”选项之后提到。
				通常，链接器会从DT NEEDED标记为每个动态库添加一个DT NEEDED标记。
				' -no-add-needed '导致DT NEEDED标签永远不会从DT NEEDED标签发出那些库的DT NEEDED标签。
				'——add-needed '恢复默认行为。
		-assert keyword
				对于SunOS兼容性，将忽略此选项。
		-Bdynamic
		-dy
		-call_shared
				链接到动态库。
				这只在支持共享库的平台上有意义。
				在此类平台上，该选项通常是默认选项。这个选项的不同变体是为了兼容不同的系统。
				你可以在命令行中多次使用这个选项:它会影响对它后面的' -l '选项的库搜索。
		-Bgroup
				在dynamic部分的DT_FLAGS_1表项中设置DF_1_GROUP标志。
				这将导致运行时链接器处理此对象中的查找，而其依赖项仅在组内执行。
				——unresolved-symbols =报告所有的暗示。这个选项只在支持共享库的ELF平台上有意义。

＿＿＿
＿＿＿
＿＿＿
＿＿＿
＿＿＿
___


